{
  "title": "Firebird + PostgreSQL - synchronizacja baz w praktyce",
  "summary": "Jak zsynchronizować dane między Firebird a PostgreSQL w środowisku produkcyjnym.",
  "content": "## Problem\n\nWiele starszych systemów ERP używa Firebird jako bazy danych. Gdy potrzebujemy zintegrować je z nowoczesnymi aplikacjami używającymi PostgreSQL, musimy zsynchronizować dane.\n\n## Architektura rozwiązania\n\nFirebird (source) → Sync Service → PostgreSQL (target)\n\n## Połączenie z Firebird\n\nUżywam FirebirdSql.Data.FirebirdClient:\n\n```csharp\nvar connectionString = new FbConnectionStringBuilder\n{\n    Database = @\"C:\\Data\\database.fdb\",\n    UserID = \"SYSDBA\",\n    Password = \"masterkey\",\n    ServerType = FbServerType.Embedded,\n    Charset = \"WIN1250\"\n}.ToString();\n\nusing var connection = new FbConnection(connectionString);\nawait connection.OpenAsync();\n```\n\n## Mapowanie typów\n\n| Firebird | PostgreSQL |\n|----------|------------|\n| INTEGER | integer |\n| BIGINT | bigint |\n| VARCHAR(n) | varchar(n) |\n| BLOB SUB_TYPE TEXT | text |\n| TIMESTAMP | timestamp |\n| DECIMAL(p,s) | numeric(p,s) |\n\n## Strategia synchronizacji\n\n### Incremental sync\n\n```csharp\npublic async Task SyncIncrementalAsync()\n{\n    var lastSync = await GetLastSyncTimestamp();\n    \n    var query = @\"\n        SELECT * FROM ORDERS \n        WHERE MODIFIED_AT > @lastSync\n        ORDER BY MODIFIED_AT\";\n    \n    using var cmd = new FbCommand(query, _fbConnection);\n    cmd.Parameters.AddWithValue(\"@lastSync\", lastSync);\n    \n    using var reader = await cmd.ExecuteReaderAsync();\n    while (await reader.ReadAsync())\n    {\n        await UpsertToPostgres(reader);\n    }\n    \n    await UpdateLastSyncTimestamp(DateTime.UtcNow);\n}\n```\n\n### Upsert do PostgreSQL\n\n```csharp\nprivate async Task UpsertToPostgres(FbDataReader reader)\n{\n    var sql = @\"\n        INSERT INTO orders (id, customer_id, total, created_at)\n        VALUES (@id, @customerId, @total, @createdAt)\n        ON CONFLICT (id) DO UPDATE SET\n            customer_id = EXCLUDED.customer_id,\n            total = EXCLUDED.total,\n            created_at = EXCLUDED.created_at\";\n    \n    using var cmd = new NpgsqlCommand(sql, _pgConnection);\n    cmd.Parameters.AddWithValue(\"@id\", reader.GetInt32(0));\n    cmd.Parameters.AddWithValue(\"@customerId\", reader.GetInt32(1));\n    cmd.Parameters.AddWithValue(\"@total\", reader.GetDecimal(2));\n    cmd.Parameters.AddWithValue(\"@createdAt\", reader.GetDateTime(3));\n    \n    await cmd.ExecuteNonQueryAsync();\n}\n```\n\n## Windows Service z Topshelf\n\n```csharp\npublic class SyncService : ServiceControl\n{\n    private Timer _timer;\n    \n    public bool Start(HostControl hostControl)\n    {\n        _timer = new Timer(async _ => await SyncAsync(), \n            null, TimeSpan.Zero, TimeSpan.FromMinutes(5));\n        return true;\n    }\n    \n    public bool Stop(HostControl hostControl)\n    {\n        _timer?.Dispose();\n        return true;\n    }\n}\n```\n\n## Obsługa błędów\n\n1. **Retry z exponential backoff** - dla transient errors\n2. **Dead letter queue** - dla rekordów które nie mogą być zsynchronizowane\n3. **Alerting** - email przy krytycznych błędach"
}