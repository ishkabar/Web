{
  "title": "Firebird + PostgreSQL - Datenbanksynchronisation in der Praxis",
  "summary": "Wie man Daten zwischen Firebird und PostgreSQL in einer Produktionsumgebung synchronisiert.",
  "content": "## Problem\n\nViele Legacy-ERP-Systeme verwenden Firebird als Datenbank. Wenn wir sie mit modernen Anwendungen integrieren müssen, die PostgreSQL verwenden, müssen wir die Daten synchronisieren.\n\n## Lösungsarchitektur\n\n```\n┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n│  Firebird   │────▶│   Sync      │────▶│ PostgreSQL  │\n│  (source)   │     │  Service    │     │  (target)   │\n└─────────────┘     └─────────────┘     └─────────────┘\n```\n\n## Verbindung zu Firebird\n\nIch verwende FirebirdSql.Data.FirebirdClient:\n\n```csharp\nvar connectionString = new FbConnectionStringBuilder\n{\n    Database = @\"C:\\Data\\database.fdb\",\n    UserID = \"SYSDBA\",\n    Password = \"masterkey\",\n    ServerType = FbServerType.Embedded,\n    Charset = \"WIN1250\"\n}.ToString();\n\nusing var connection = new FbConnection(connectionString);\nawait connection.OpenAsync();\n```\n\n## Typzuordnung\n\n| Firebird | PostgreSQL |\n|----------|------------|\n| INTEGER | integer |\n| BIGINT | bigint |\n| VARCHAR(n) | varchar(n) |\n| BLOB SUB_TYPE TEXT | text |\n| TIMESTAMP | timestamp |\n| DECIMAL(p,s) | numeric(p,s) |\n\n## Synchronisationsstrategie\n\n### Inkrementelle Synchronisation\n\n```csharp\npublic async Task SyncIncrementalAsync()\n{\n    var lastSync = await GetLastSyncTimestamp();\n    \n    var query = @\"\n        SELECT * FROM ORDERS \n        WHERE MODIFIED_AT > @lastSync\n        ORDER BY MODIFIED_AT\";\n    \n    using var cmd = new FbCommand(query, _fbConnection);\n    cmd.Parameters.AddWithValue(\"@lastSync\", lastSync);\n    \n    using var reader = await cmd.ExecuteReaderAsync();\n    while (await reader.ReadAsync())\n    {\n        await UpsertToPostgres(reader);\n    }\n    \n    await UpdateLastSyncTimestamp(DateTime.UtcNow);\n}\n```\n\n### Upsert zu PostgreSQL\n\n```csharp\nprivate async Task UpsertToPostgres(FbDataReader reader)\n{\n    var sql = @\"\n        INSERT INTO orders (id, customer_id, total, created_at)\n        VALUES (@id, @customerId, @total, @createdAt)\n        ON CONFLICT (id) DO UPDATE SET\n            customer_id = EXCLUDED.customer_id,\n            total = EXCLUDED.total,\n            created_at = EXCLUDED.created_at\";\n    \n    using var cmd = new NpgsqlCommand(sql, _pgConnection);\n    cmd.Parameters.AddWithValue(\"@id\", reader.GetInt32(0));\n    cmd.Parameters.AddWithValue(\"@customerId\", reader.GetInt32(1));\n    cmd.Parameters.AddWithValue(\"@total\", reader.GetDecimal(2));\n    cmd.Parameters.AddWithValue(\"@createdAt\", reader.GetDateTime(3));\n    \n    await cmd.ExecuteNonQueryAsync();\n}\n```\n\n## Windows-Dienst mit Topshelf\n\n```csharp\npublic class SyncService : ServiceControl\n{\n    private Timer _timer;\n    \n    public bool Start(HostControl hostControl)\n    {\n        _timer = new Timer(async _ => await SyncAsync(), \n            null, TimeSpan.Zero, TimeSpan.FromMinutes(5));\n        return true;\n    }\n    \n    public bool Stop(HostControl hostControl)\n    {\n        _timer?.Dispose();\n        return true;\n    }\n}\n```\n\n## Fehlerbehandlung\n\n1. **Retry mit exponential backoff** - für transiente Fehler\n2. **Dead Letter Queue** - für Datensätze, die nicht synchronisiert werden können\n3. **Alerting** - E-Mail bei kritischen Fehlern"
}