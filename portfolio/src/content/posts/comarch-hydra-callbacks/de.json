{
  "title": "Comarch Hydra SDK - Callbacks in der Praxis",
  "summary": "Event-driven ERP-Erweiterungen mit Comarch Hydra - Callbacks, UI-Injection und Session-Management.",
  "content": "## Einführung\n\nComarch Hydra SDK ermöglicht die Erstellung benutzerdefinierter Erweiterungen für ERP XL ohne Änderungen am Basissystem. In diesem Artikel zeige ich, wie man production-ready Callbacks basierend auf jahrelanger Erfahrung erstellt.\n\n## Callback-Registrierung\n\nJeder Callback beginnt mit Prozedur-Subscription:\n\n```csharp\n[SubscribeProcedure(Procedures.TrN_FS, \"Rechnungsanpassung\")]\npublic class InvoiceCallback : CallbackTemplate\n{\n    protected override void OnAfterOpenWindow()\n    {\n        base.OnAfterOpenWindow();\n        InitializeControls();\n    }\n}\n```\n\n### Verfügbare Events\n\n- `OnAfterOpenWindow` - Fenster geöffnet, Controls bereit\n- `OnBeforeCloseWindow` - vor Schließen, kann abgebrochen werden\n- `OnAfterAccepted` - Dokument gespeichert\n- `OnBeforeAccepted` - vor Speichern, Validierungspunkt\n- `ResizeWindow` - Fenster geändert, Controls neu positionieren\n\n## Dynamische UI-Injection\n\n### Hinzufügen eigener Schaltfläche\n\n```csharp\nprotected override void CreateControls()\n{\n    var anchor = GetControlByName(\"IrgendeinBestehendesControl\");\n    if (anchor == null) return;\n    \n    var button = AddControl(\n        anchor,\n        ControlTypes.button,\n        (anchorBounds, ref bounds) =>\n        {\n            bounds.X = anchorBounds.Right + 10;\n            bounds.Y = anchorBounds.Top;\n            bounds.Width = 120;\n            bounds.Height = 25;\n        });\n    \n    button.ScreenTextRaw = \"Verarbeiten\";\n    button.OnAfterAccepted += ProcessDocument;\n}\n```\n\n### Control-Positionierungsmuster\n\n```csharp\nprivate Rectangle CalculateBounds(\n    Rectangle anchor, \n    int offsetX, \n    int offsetY)\n{\n    return new Rectangle(\n        anchor.Right + offsetX,\n        anchor.Top + offsetY,\n        120,\n        25\n    );\n}\n```\n\n## Session-Management\n\nKritisch in Multi-Threading-Umgebungen:\n\n```csharp\nprotected override bool ProcessDocument(\n    CallbackParameters p,\n    CallbackEventArgs e)\n{\n    // An Clarion-Thread anhängen\n    AttachThreadToClarion(1);\n    \n    try\n    {\n        var sessionId = GetCurrentSessionId();\n        var threadId = Thread.CurrentThread.ManagedThreadId;\n        \n        _logger.Info($\"Verarbeitung in Session {sessionId}, Thread {threadId}\");\n        \n        // Ihre Logik hier\n        return ProcessDocumentLogic(p, e);\n    }\n    finally\n    {\n        DetachThreadFromClarion();\n    }\n}\n```\n\n### Thread-Safety-Muster\n\n```csharp\nprivate static readonly object _lock = new object();\nprivate static Dictionary<int, SessionContext> _sessions = new();\n\nprivate SessionContext GetOrCreateSession(int sessionId)\n{\n    lock (_lock)\n    {\n        if (!_sessions.TryGetValue(sessionId, out var context))\n        {\n            context = new SessionContext { SessionId = sessionId };\n            _sessions[sessionId] = context;\n        }\n        return context;\n    }\n}\n```\n\n## Arbeiten mit Dokumenten\n\n### Dokumentdaten lesen\n\n```csharp\nprivate decimal GetDocumentTotal()\n{\n    var gidTyp = GetFieldValue<int>(\"TrN_GIDTyp\");\n    var gidNumer = GetFieldValue<int>(\"TrN_GIDNumer\");\n    \n    using var db = new XLDatabase();\n    return db.Documents\n        .Where(d => d.GIDTyp == gidTyp && d.GIDNumer == gidNumer)\n        .Select(d => d.Wartosc)\n        .FirstOrDefault();\n}\n```\n\n### Dokument über API modifizieren\n\n```csharp\nprivate void UpdateDocument()\n{\n    var doc = ModifyShowedDocument();\n    if (doc == null) return;\n    \n    try\n    {\n        doc.SetValue(\"TrN_Uwagi\", \"Durch Callback verarbeitet\");\n        doc.Save();\n        \n        RefreshForm();\n    }\n    catch (Exception ex)\n    {\n        _logger.Error(ex, \"Dokumentaktualisierung fehlgeschlagen\");\n        ShowError(\"Aktualisierung fehlgeschlagen\");\n    }\n}\n```\n\n## Listenverarbeitung\n\n### Markierte Elemente abrufen\n\n```csharp\nprivate List<int> GetMarkedElements(ClaWindow list)\n{\n    var marked = new List<int>();\n    var count = list.GetListCount();\n    \n    for (int i = 1; i <= count; i++)\n    {\n        if (list.IsListItemMarked(i))\n        {\n            list.SelectListItem(i);\n            var id = GetFieldValue<int>(\"ElementId\");\n            marked.Add(id);\n        }\n    }\n    \n    return marked;\n}\n```\n\n### Batch-Processing-Muster\n\n```csharp\nprivate async Task ProcessBatch(List<int> ids)\n{\n    var progress = 0;\n    var total = ids.Count;\n    \n    foreach (var id in ids)\n    {\n        try\n        {\n            await ProcessSingleItem(id);\n            progress++;\n            UpdateProgress(progress, total);\n        }\n        catch (Exception ex)\n        {\n            _logger.Error(ex, $\"Element {id} konnte nicht verarbeitet werden\");\n        }\n    }\n}\n```\n\n## Fehlerbehandlung\n\n### Benutzerfreundliche Meldungen\n\n```csharp\nprivate void ShowError(string message)\n{\n    MessageBox.Show(\n        message,\n        \"Fehler\",\n        MessageBoxButtons.OK,\n        MessageBoxIcon.Error);\n}\n\nprivate bool ShowConfirm(string message)\n{\n    return MessageBox.Show(\n        message,\n        \"Bestätigung\",\n        MessageBoxButtons.YesNo,\n        MessageBoxIcon.Question) == DialogResult.Yes;\n}\n```\n\n## Logging Best Practices\n\n```csharp\nprivate static readonly ILogger _logger = LogManager.GetCurrentClassLogger();\n\nprotected override void OnAfterOpenWindow()\n{\n    try\n    {\n        _logger.Debug(\"Fenster geöffnet\");\n        base.OnAfterOpenWindow();\n        InitializeControls();\n    }\n    catch (Exception ex)\n    {\n        _logger.Error(ex, \"Controls konnten nicht initialisiert werden\");\n        throw;\n    }\n}\n```\n\n## Häufige Fehler\n\n1. **AttachThreadToClarion vergessen** - verursacht Access Violations\n2. **Keine Null-Prüfung bei GetControlByName** - Controls existieren möglicherweise nicht\n3. **UI-Thread blockieren** - async für lange Operationen verwenden\n4. **Memory Leaks** - Ressourcen ordnungsgemäß freigeben\n5. **Session-Vermischung** - immer aktuelle Session-ID abrufen\n\n## Production Checklist\n\n- ✅ Umfassende Fehlerbehandlung\n- ✅ Strukturiertes Logging mit Kontext\n- ✅ Thread-Sicherheit für gemeinsamen Zustand\n- ✅ Benutzerbestätigung für destruktive Aktionen\n- ✅ Fortschrittsindikatoren für Batch-Operationen\n- ✅ Graceful Degradation bei API-Fehlern"
}
