{
  "title": "Comarch Hydra SDK - Callbacks w Praktyce",
  "summary": "Tworzenie rozszerzeń ERP w architekturze event-driven z Comarch Hydra - callbacki, wstrzykiwanie UI i zarządzanie sesjami.",
  "content": "## Wprowadzenie\n\nComarch Hydra SDK umożliwia tworzenie niestandardowych rozszerzeń dla ERP XL bez modyfikacji systemu bazowego. W tym artykule pokażę jak budować production-ready callbacki na podstawie lat doświadczenia.\n\n## Rejestracja Callbacka\n\nKażdy callback zaczyna się od subskrypcji procedury:\n\n```csharp\n[SubscribeProcedure(Procedures.TrN_FS, \"Dostosowanie Faktury\")]\npublic class InvoiceCallback : CallbackTemplate\n{\n    protected override void OnAfterOpenWindow()\n    {\n        base.OnAfterOpenWindow();\n        InitializeControls();\n    }\n}\n```\n\n### Dostępne Eventy\n\n- `OnAfterOpenWindow` - okno otwarte, kontrolki gotowe\n- `OnBeforeCloseWindow` - przed zamknięciem, można anulować\n- `OnAfterAccepted` - dokument zapisany\n- `OnBeforeAccepted` - przed zapisem, punkt walidacji\n- `ResizeWindow` - okno zmienione, repozycjonuj kontrolki\n\n## Dynamiczne Wstrzykiwanie UI\n\n### Dodawanie Własnego Przycisku\n\n```csharp\nprotected override void CreateControls()\n{\n    var anchor = GetControlByName(\"JakasIstniejacaKontrolka\");\n    if (anchor == null) return;\n    \n    var button = AddControl(\n        anchor,\n        ControlTypes.button,\n        (anchorBounds, ref bounds) =>\n        {\n            bounds.X = anchorBounds.Right + 10;\n            bounds.Y = anchorBounds.Top;\n            bounds.Width = 120;\n            bounds.Height = 25;\n        });\n    \n    button.ScreenTextRaw = \"Przetwórz\";\n    button.OnAfterAccepted += ProcessDocument;\n}\n```\n\n### Wzorzec Pozycjonowania Kontrolek\n\n```csharp\nprivate Rectangle CalculateBounds(\n    Rectangle anchor, \n    int offsetX, \n    int offsetY)\n{\n    return new Rectangle(\n        anchor.Right + offsetX,\n        anchor.Top + offsetY,\n        120,\n        25\n    );\n}\n```\n\n## Zarządzanie Sesjami\n\nKluczowe w środowiskach wielowątkowych:\n\n```csharp\nprotected override bool ProcessDocument(\n    CallbackParameters p,\n    CallbackEventArgs e)\n{\n    // Przyłącz do wątku Clarion\n    AttachThreadToClarion(1);\n    \n    try\n    {\n        var sessionId = GetCurrentSessionId();\n        var threadId = Thread.CurrentThread.ManagedThreadId;\n        \n        _logger.Info($\"Przetwarzanie w sesji {sessionId}, wątek {threadId}\");\n        \n        // Twoja logika tutaj\n        return ProcessDocumentLogic(p, e);\n    }\n    finally\n    {\n        DetachThreadFromClarion();\n    }\n}\n```\n\n### Wzorzec Thread Safety\n\n```csharp\nprivate static readonly object _lock = new object();\nprivate static Dictionary<int, SessionContext> _sessions = new();\n\nprivate SessionContext GetOrCreateSession(int sessionId)\n{\n    lock (_lock)\n    {\n        if (!_sessions.TryGetValue(sessionId, out var context))\n        {\n            context = new SessionContext { SessionId = sessionId };\n            _sessions[sessionId] = context;\n        }\n        return context;\n    }\n}\n```\n\n## Praca z Dokumentami\n\n### Odczyt Danych Dokumentu\n\n```csharp\nprivate decimal GetDocumentTotal()\n{\n    var gidTyp = GetFieldValue<int>(\"TrN_GIDTyp\");\n    var gidNumer = GetFieldValue<int>(\"TrN_GIDNumer\");\n    \n    using var db = new XLDatabase();\n    return db.Documents\n        .Where(d => d.GIDTyp == gidTyp && d.GIDNumer == gidNumer)\n        .Select(d => d.Wartosc)\n        .FirstOrDefault();\n}\n```\n\n### Modyfikacja Dokumentu przez API\n\n```csharp\nprivate void UpdateDocument()\n{\n    var doc = ModifyShowedDocument();\n    if (doc == null) return;\n    \n    try\n    {\n        doc.SetValue(\"TrN_Uwagi\", \"Przetworzony przez callback\");\n        doc.Save();\n        \n        RefreshForm();\n    }\n    catch (Exception ex)\n    {\n        _logger.Error(ex, \"Nie udało się zaktualizować dokumentu\");\n        ShowError(\"Aktualizacja nie powiodła się\");\n    }\n}\n```\n\n## Przetwarzanie List\n\n### Pobieranie Zaznaczonych Elementów\n\n```csharp\nprivate List<int> GetMarkedElements(ClaWindow list)\n{\n    var marked = new List<int>();\n    var count = list.GetListCount();\n    \n    for (int i = 1; i <= count; i++)\n    {\n        if (list.IsListItemMarked(i))\n        {\n            list.SelectListItem(i);\n            var id = GetFieldValue<int>(\"ElementId\");\n            marked.Add(id);\n        }\n    }\n    \n    return marked;\n}\n```\n\n### Wzorzec Batch Processing\n\n```csharp\nprivate async Task ProcessBatch(List<int> ids)\n{\n    var progress = 0;\n    var total = ids.Count;\n    \n    foreach (var id in ids)\n    {\n        try\n        {\n            await ProcessSingleItem(id);\n            progress++;\n            UpdateProgress(progress, total);\n        }\n        catch (Exception ex)\n        {\n            _logger.Error(ex, $\"Nie udało się przetworzyć elementu {id}\");\n        }\n    }\n}\n```\n\n## Obsługa Błędów\n\n### Komunikaty Dla Użytkownika\n\n```csharp\nprivate void ShowError(string message)\n{\n    MessageBox.Show(\n        message,\n        \"Błąd\",\n        MessageBoxButtons.OK,\n        MessageBoxIcon.Error);\n}\n\nprivate bool ShowConfirm(string message)\n{\n    return MessageBox.Show(\n        message,\n        \"Potwierdzenie\",\n        MessageBoxButtons.YesNo,\n        MessageBoxIcon.Question) == DialogResult.Yes;\n}\n```\n\n## Najlepsze Praktyki Logowania\n\n```csharp\nprivate static readonly ILogger _logger = LogManager.GetCurrentClassLogger();\n\nprotected override void OnAfterOpenWindow()\n{\n    try\n    {\n        _logger.Debug(\"Okno otwarte\");\n        base.OnAfterOpenWindow();\n        InitializeControls();\n    }\n    catch (Exception ex)\n    {\n        _logger.Error(ex, \"Nie udało się zainicjalizować kontrolek\");\n        throw;\n    }\n}\n```\n\n## Częste Pułapki\n\n1. **Zapomnienie AttachThreadToClarion** - powoduje access violations\n2. **Brak sprawdzenia null przy GetControlByName** - kontrolki mogą nie istnieć\n3. **Blokowanie wątku UI** - użyj async dla długich operacji\n4. **Memory leaks** - prawidłowo zwalniaj zasoby\n5. **Mieszanie sesji** - zawsze pobieraj aktualny session ID\n\n## Production Checklist\n\n- ✅ Kompleksowa obsługa błędów\n- ✅ Strukturalne logowanie z kontekstem\n- ✅ Thread safety dla współdzielonego stanu\n- ✅ Potwierdzenie użytkownika dla destrukcyjnych akcji\n- ✅ Wskaźniki postępu dla operacji wsadowych\n- ✅ Graceful degradation gdy API zawodzi"
}
