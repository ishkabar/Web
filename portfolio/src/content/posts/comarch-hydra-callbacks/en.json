{
  "title": "Comarch Hydra SDK - Custom Callbacks Deep Dive",
  "summary": "Building event-driven ERP extensions with Comarch Hydra - callbacks, UI injections, and session management patterns.",
  "content": "## Introduction\n\nComarch Hydra SDK enables creating custom extensions for ERP XL without modifying the core system. In this article, I'll show you how to build production-ready callbacks based on years of experience.\n\n## Callback Registration\n\nEvery callback starts with procedure subscription:\n\n```csharp\n[SubscribeProcedure(Procedures.TrN_FS, \"Invoice Customization\")]\npublic class InvoiceCallback : CallbackTemplate\n{\n    protected override void OnAfterOpenWindow()\n    {\n        base.OnAfterOpenWindow();\n        InitializeControls();\n    }\n}\n```\n\n### Available Events\n\n- `OnAfterOpenWindow` - window opened, controls ready\n- `OnBeforeCloseWindow` - before closing, can cancel\n- `OnAfterAccepted` - document saved\n- `OnBeforeAccepted` - before save, validation point\n- `ResizeWindow` - window resized, reposition controls\n\n## Dynamic UI Injection\n\n### Adding Custom Button\n\n```csharp\nprotected override void CreateControls()\n{\n    var anchor = GetControlByName(\"SomeExistingControl\");\n    if (anchor == null) return;\n    \n    var button = AddControl(\n        anchor,\n        ControlTypes.button,\n        (anchorBounds, ref bounds) =>\n        {\n            bounds.X = anchorBounds.Right + 10;\n            bounds.Y = anchorBounds.Top;\n            bounds.Width = 120;\n            bounds.Height = 25;\n        });\n    \n    button.ScreenTextRaw = \"Process\";\n    button.OnAfterAccepted += ProcessDocument;\n}\n```\n\n### Control Positioning Pattern\n\n```csharp\nprivate Rectangle CalculateBounds(\n    Rectangle anchor, \n    int offsetX, \n    int offsetY)\n{\n    return new Rectangle(\n        anchor.Right + offsetX,\n        anchor.Top + offsetY,\n        120,\n        25\n    );\n}\n```\n\n## Session Management\n\nCritical for multi-threaded environments:\n\n```csharp\nprotected override bool ProcessDocument(\n    CallbackParameters p,\n    CallbackEventArgs e)\n{\n    // Attach to Clarion thread\n    AttachThreadToClarion(1);\n    \n    try\n    {\n        var sessionId = GetCurrentSessionId();\n        var threadId = Thread.CurrentThread.ManagedThreadId;\n        \n        _logger.Info($\"Processing in session {sessionId}, thread {threadId}\");\n        \n        // Your logic here\n        return ProcessDocumentLogic(p, e);\n    }\n    finally\n    {\n        DetachThreadFromClarion();\n    }\n}\n```\n\n### Thread Safety Pattern\n\n```csharp\nprivate static readonly object _lock = new object();\nprivate static Dictionary<int, SessionContext> _sessions = new();\n\nprivate SessionContext GetOrCreateSession(int sessionId)\n{\n    lock (_lock)\n    {\n        if (!_sessions.TryGetValue(sessionId, out var context))\n        {\n            context = new SessionContext { SessionId = sessionId };\n            _sessions[sessionId] = context;\n        }\n        return context;\n    }\n}\n```\n\n## Working with Documents\n\n### Reading Document Data\n\n```csharp\nprivate decimal GetDocumentTotal()\n{\n    var gidTyp = GetFieldValue<int>(\"TrN_GIDTyp\");\n    var gidNumer = GetFieldValue<int>(\"TrN_GIDNumer\");\n    \n    using var db = new XLDatabase();\n    return db.Documents\n        .Where(d => d.GIDTyp == gidTyp && d.GIDNumer == gidNumer)\n        .Select(d => d.Wartosc)\n        .FirstOrDefault();\n}\n```\n\n### Modifying Document with API\n\n```csharp\nprivate void UpdateDocument()\n{\n    var doc = ModifyShowedDocument();\n    if (doc == null) return;\n    \n    try\n    {\n        doc.SetValue(\"TrN_Uwagi\", \"Processed by callback\");\n        doc.Save();\n        \n        RefreshForm();\n    }\n    catch (Exception ex)\n    {\n        _logger.Error(ex, \"Failed to update document\");\n        ShowError(\"Update failed\");\n    }\n}\n```\n\n## List Processing\n\n### Getting Selected Items\n\n```csharp\nprivate List<int> GetMarkedElements(ClaWindow list)\n{\n    var marked = new List<int>();\n    var count = list.GetListCount();\n    \n    for (int i = 1; i <= count; i++)\n    {\n        if (list.IsListItemMarked(i))\n        {\n            list.SelectListItem(i);\n            var id = GetFieldValue<int>(\"ElementId\");\n            marked.Add(id);\n        }\n    }\n    \n    return marked;\n}\n```\n\n### Batch Processing Pattern\n\n```csharp\nprivate async Task ProcessBatch(List<int> ids)\n{\n    var progress = 0;\n    var total = ids.Count;\n    \n    foreach (var id in ids)\n    {\n        try\n        {\n            await ProcessSingleItem(id);\n            progress++;\n            UpdateProgress(progress, total);\n        }\n        catch (Exception ex)\n        {\n            _logger.Error(ex, $\"Failed to process item {id}\");\n        }\n    }\n}\n```\n\n## Error Handling\n\n### User-Friendly Messages\n\n```csharp\nprivate void ShowError(string message)\n{\n    MessageBox.Show(\n        message,\n        \"Error\",\n        MessageBoxButtons.OK,\n        MessageBoxIcon.Error);\n}\n\nprivate bool ShowConfirm(string message)\n{\n    return MessageBox.Show(\n        message,\n        \"Confirmation\",\n        MessageBoxButtons.YesNo,\n        MessageBoxIcon.Question) == DialogResult.Yes;\n}\n```\n\n## Logging Best Practices\n\n```csharp\nprivate static readonly ILogger _logger = LogManager.GetCurrentClassLogger();\n\nprotected override void OnAfterOpenWindow()\n{\n    try\n    {\n        _logger.Debug(\"Window opened\");\n        base.OnAfterOpenWindow();\n        InitializeControls();\n    }\n    catch (Exception ex)\n    {\n        _logger.Error(ex, \"Failed to initialize controls\");\n        throw;\n    }\n}\n```\n\n## Common Pitfalls\n\n1. **Forgetting AttachThreadToClarion** - causes access violations\n2. **Not checking null on GetControlByName** - controls may not exist\n3. **Blocking UI thread** - use async for long operations\n4. **Memory leaks** - properly dispose resources\n5. **Session mixing** - always get current session ID\n\n## Production Checklist\n\n- ✅ Comprehensive error handling\n- ✅ Structured logging with context\n- ✅ Thread safety for shared state\n- ✅ User confirmation for destructive actions\n- ✅ Progress indicators for batch operations\n- ✅ Graceful degradation when API fails"
}
