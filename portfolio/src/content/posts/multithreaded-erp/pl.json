{
  "title": "Wielowątkowa Automatyzacja ERP - Unikanie Race Conditions",
  "summary": "Praktyczne wzorce thread-safe automatyzacji ERP z AttachThreadToClarion i właściwą synchronizacją.",
  "content": "## Wprowadzenie\n\nSystemy ERP jak Comarch XL używają runtime Clarion który wymaga specyficznego zarządzania wątkami. Nieprawidłowa obsługa prowadzi do race conditions, korupcji danych i access violations. Ten artykuł pokazuje sprawdzone wzorce z systemów produkcyjnych.\n\n## Problem\n\n### Przykład Race Condition\n\n```csharp\n// ŹLE - Race condition\nprivate static int _documentCounter = 0;\n\npublic void ProcessDocument()\n{\n    _documentCounter++; // Nie jest thread-safe!\n    var docNumber = _documentCounter;\n    SaveDocument(docNumber);\n}\n```\n\nWiele wątków inkrementujących licznik jednocześnie:\n- Wątek A czyta 100\n- Wątek B czyta 100\n- Wątek A zapisuje 101\n- Wątek B zapisuje 101 (powinno być 102!)\n\n## Wzorzec AttachThreadToClarion\n\n### Dlaczego jest potrzebny\n\nRuntime Clarion używa thread-local storage. Każde wywołanie API musi działać na przyłączonym wątku:\n\n```csharp\npublic void ProcessInBackground()\n{\n    Task.Run(() =>\n    {\n        // ŹLE - Access violation!\n        var doc = GetDocument();\n    });\n}\n```\n\n### Poprawny Wzorzec\n\n```csharp\npublic void ProcessInBackground()\n{\n    Task.Run(() =>\n    {\n        AttachThreadToClarion(1);\n        try\n        {\n            var doc = GetDocument();\n            ProcessDocument(doc);\n        }\n        finally\n        {\n            DetachThreadFromClarion();\n        }\n    });\n}\n```\n\n## Synchronizacja Wątków\n\n### Wzorzec Lock\n\n```csharp\nprivate static readonly object _lock = new object();\nprivate static Dictionary<int, DocumentState> _states = new();\n\npublic void UpdateDocumentState(int docId, DocumentState state)\n{\n    lock (_lock)\n    {\n        _states[docId] = state;\n    }\n}\n\npublic DocumentState GetDocumentState(int docId)\n{\n    lock (_lock)\n    {\n        return _states.TryGetValue(docId, out var state) \n            ? state \n            : DocumentState.Unknown;\n    }\n}\n```\n\n### SemaphoreSlim dla Async\n\n```csharp\nprivate static readonly SemaphoreSlim _semaphore = new(1, 1);\n\npublic async Task UpdateDocumentAsync(int docId)\n{\n    await _semaphore.WaitAsync();\n    try\n    {\n        AttachThreadToClarion(1);\n        try\n        {\n            var doc = GetDocument(docId);\n            await ProcessDocumentAsync(doc);\n        }\n        finally\n        {\n            DetachThreadFromClarion();\n        }\n    }\n    finally\n    {\n        _semaphore.Release();\n    }\n}\n```\n\n## Izolacja Sesji\n\n### Wzorzec Session-Per-Thread\n\n```csharp\nprivate static readonly ThreadLocal<SessionContext> _sessionContext = \n    new ThreadLocal<SessionContext>(() => new SessionContext());\n\npublic void ProcessDocument()\n{\n    AttachThreadToClarion(1);\n    try\n    {\n        var context = _sessionContext.Value;\n        context.SessionId = GetCurrentSessionId();\n        context.ThreadId = Thread.CurrentThread.ManagedThreadId;\n        \n        _logger.Info($\"Sesja {context.SessionId} na wątku {context.ThreadId}\");\n        \n        ProcessWithContext(context);\n    }\n    finally\n    {\n        DetachThreadFromClarion();\n    }\n}\n```\n\n### Klasa Session Context\n\n```csharp\npublic class SessionContext\n{\n    public int SessionId { get; set; }\n    public int ThreadId { get; set; }\n    public DateTime StartTime { get; set; } = DateTime.UtcNow;\n    public Dictionary<string, object> Data { get; } = new();\n}\n```\n\n## Kolekcje Współbieżne\n\n### ConcurrentDictionary\n\n```csharp\nprivate static readonly ConcurrentDictionary<int, ProcessingState> _processing = new();\n\npublic bool TryStartProcessing(int docId)\n{\n    return _processing.TryAdd(docId, new ProcessingState\n    {\n        StartedAt = DateTime.UtcNow,\n        ThreadId = Thread.CurrentThread.ManagedThreadId\n    });\n}\n\npublic void FinishProcessing(int docId)\n{\n    _processing.TryRemove(docId, out _);\n}\n```\n\n### ConcurrentQueue do Dystrybucji Zadań\n\n```csharp\nprivate static readonly ConcurrentQueue<DocumentTask> _taskQueue = new();\n\npublic void EnqueueTask(DocumentTask task)\n{\n    _taskQueue.Enqueue(task);\n}\n\npublic void ProcessQueue()\n{\n    while (_taskQueue.TryDequeue(out var task))\n    {\n        AttachThreadToClarion(1);\n        try\n        {\n            ProcessTask(task);\n        }\n        finally\n        {\n            DetachThreadFromClarion();\n        }\n    }\n}\n```\n\n## Wzorzec Przetwarzania Równoległego\n\n### Parallel.ForEach z Clarion\n\n```csharp\npublic void ProcessDocumentsBatch(List<int> documentIds)\n{\n    var options = new ParallelOptions\n    {\n        MaxDegreeOfParallelism = 4 // Ogranicz wątki\n    };\n    \n    Parallel.ForEach(documentIds, options, docId =>\n    {\n        AttachThreadToClarion(1);\n        try\n        {\n            ProcessSingleDocument(docId);\n        }\n        catch (Exception ex)\n        {\n            _logger.Error(ex, $\"Nie udało się przetworzyć dokumentu {docId}\");\n        }\n        finally\n        {\n            DetachThreadFromClarion();\n        }\n    });\n}\n```\n\n## Zapobieganie Deadlockom\n\n### Kolejność Lockowania\n\n```csharp\n// ŹLE - Może deadlockować\npublic void Transfer(Account from, Account to, decimal amount)\n{\n    lock (from)\n    {\n        lock (to)\n        {\n            from.Balance -= amount;\n            to.Balance += amount;\n        }\n    }\n}\n\n// DOBRZE - Zawsze lockuj w tej samej kolejności\npublic void Transfer(Account from, Account to, decimal amount)\n{\n    var first = from.Id < to.Id ? from : to;\n    var second = from.Id < to.Id ? to : from;\n    \n    lock (first)\n    {\n        lock (second)\n        {\n            from.Balance -= amount;\n            to.Balance += amount;\n        }\n    }\n}\n```\n\n### Wzorzec Timeout\n\n```csharp\npublic bool TryProcessWithTimeout(int docId, TimeSpan timeout)\n{\n    if (!Monitor.TryEnter(_lock, timeout))\n    {\n        _logger.Warn($\"Timeout przy nabywaniu locka dla dokumentu {docId}\");\n        return false;\n    }\n    \n    try\n    {\n        ProcessDocument(docId);\n        return true;\n    }\n    finally\n    {\n        Monitor.Exit(_lock);\n    }\n}\n```\n\n## Testowanie Race Conditions\n\n### Stress Test\n\n```csharp\n[Test]\npublic async Task StressTest_ConcurrentDocumentProcessing()\n{\n    const int threadCount = 10;\n    const int iterationsPerThread = 100;\n    var errors = new ConcurrentBag<Exception>();\n    \n    var tasks = Enumerable.Range(0, threadCount)\n        .Select(async i =>\n        {\n            for (int j = 0; j < iterationsPerThread; j++)\n            {\n                try\n                {\n                    await ProcessDocumentAsync(i * iterationsPerThread + j);\n                }\n                catch (Exception ex)\n                {\n                    errors.Add(ex);\n                }\n            }\n        });\n    \n    await Task.WhenAll(tasks);\n    \n    Assert.IsEmpty(errors, $\"Znaleziono {errors.Count} błędów\");\n}\n```\n\n## Monitoring\n\n### Metryki Thread Pool\n\n```csharp\npublic class ThreadPoolMonitor\n{\n    public static void LogStatus()\n    {\n        ThreadPool.GetAvailableThreads(out var workerThreads, out var ioThreads);\n        ThreadPool.GetMaxThreads(out var maxWorkerThreads, out var maxIoThreads);\n        \n        _logger.Info($\"ThreadPool: {maxWorkerThreads - workerThreads}/{maxWorkerThreads} worker, \" +\n                     $\"{maxIoThreads - ioThreads}/{maxIoThreads} IO\");\n    }\n}\n```\n\n## Częste Pułapki\n\n1. **Zapomnienie DetachThreadFromClarion** - memory leak\n2. **Współdzielenie obiektów ERP między wątkami** - korupcja\n3. **Brak locków dla współdzielonego stanu** - race conditions\n4. **Blokowanie wątków ThreadPool** - starvation\n5. **Zagnieżdżone locki bez kolejności** - deadlocki\n\n## Production Checklist\n\n- ✅ Wszystkie wywołania ERP API opakowane w Attach/Detach\n- ✅ Współdzielony stan chroniony lockami\n- ✅ Kolejność lockowania udokumentowana i wymuszana\n- ✅ Timeouty dla nabywania locków\n- ✅ Monitoring thread pool\n- ✅ Stress testy dla race conditions\n- ✅ Obsługa wyjątków we wszystkich wątkach"
}
