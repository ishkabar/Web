{
  "title": "Multi-threaded ERP-Automatisierung - Race Conditions vermeiden",
  "summary": "Praktische Muster für thread-sichere ERP-Automatisierung mit AttachThreadToClarion und korrekter Synchronisierung.",
  "content": "## Einführung\n\nERP-Systeme wie Comarch XL verwenden Clarion-Runtime, die spezifisches Thread-Management erfordert. Unsachgemäße Handhabung führt zu Race Conditions, Datenkorruption und Access Violations. Dieser Artikel zeigt bewährte Muster aus Produktionssystemen.\n\n## Das Problem\n\n### Race Condition Beispiel\n\n```csharp\n// FALSCH - Race Condition\nprivate static int _documentCounter = 0;\n\npublic void ProcessDocument()\n{\n    _documentCounter++; // Nicht thread-safe!\n    var docNumber = _documentCounter;\n    SaveDocument(docNumber);\n}\n```\n\nMehrere Threads inkrementieren Counter gleichzeitig:\n- Thread A liest 100\n- Thread B liest 100\n- Thread A schreibt 101\n- Thread B schreibt 101 (sollte 102 sein!)\n\n## AttachThreadToClarion-Muster\n\n### Warum es benötigt wird\n\nClarion-Runtime verwendet Thread-Local-Storage. Jeder API-Aufruf muss auf angehängtem Thread laufen:\n\n```csharp\npublic void ProcessInBackground()\n{\n    Task.Run(() =>\n    {\n        // FALSCH - Access Violation!\n        var doc = GetDocument();\n    });\n}\n```\n\n### Korrektes Muster\n\n```csharp\npublic void ProcessInBackground()\n{\n    Task.Run(() =>\n    {\n        AttachThreadToClarion(1);\n        try\n        {\n            var doc = GetDocument();\n            ProcessDocument(doc);\n        }\n        finally\n        {\n            DetachThreadFromClarion();\n        }\n    });\n}\n```\n\n## Thread-Synchronisierung\n\n### Lock-Muster\n\n```csharp\nprivate static readonly object _lock = new object();\nprivate static Dictionary<int, DocumentState> _states = new();\n\npublic void UpdateDocumentState(int docId, DocumentState state)\n{\n    lock (_lock)\n    {\n        _states[docId] = state;\n    }\n}\n\npublic DocumentState GetDocumentState(int docId)\n{\n    lock (_lock)\n    {\n        return _states.TryGetValue(docId, out var state) \n            ? state \n            : DocumentState.Unknown;\n    }\n}\n```\n\n### SemaphoreSlim für Async\n\n```csharp\nprivate static readonly SemaphoreSlim _semaphore = new(1, 1);\n\npublic async Task UpdateDocumentAsync(int docId)\n{\n    await _semaphore.WaitAsync();\n    try\n    {\n        AttachThreadToClarion(1);\n        try\n        {\n            var doc = GetDocument(docId);\n            await ProcessDocumentAsync(doc);\n        }\n        finally\n        {\n            DetachThreadFromClarion();\n        }\n    }\n    finally\n    {\n        _semaphore.Release();\n    }\n}\n```\n\n## Session-Isolation\n\n### Session-Per-Thread-Muster\n\n```csharp\nprivate static readonly ThreadLocal<SessionContext> _sessionContext = \n    new ThreadLocal<SessionContext>(() => new SessionContext());\n\npublic void ProcessDocument()\n{\n    AttachThreadToClarion(1);\n    try\n    {\n        var context = _sessionContext.Value;\n        context.SessionId = GetCurrentSessionId();\n        context.ThreadId = Thread.CurrentThread.ManagedThreadId;\n        \n        _logger.Info($\"Session {context.SessionId} auf Thread {context.ThreadId}\");\n        \n        ProcessWithContext(context);\n    }\n    finally\n    {\n        DetachThreadFromClarion();\n    }\n}\n```\n\n### Session Context Klasse\n\n```csharp\npublic class SessionContext\n{\n    public int SessionId { get; set; }\n    public int ThreadId { get; set; }\n    public DateTime StartTime { get; set; } = DateTime.UtcNow;\n    public Dictionary<string, object> Data { get; } = new();\n}\n```\n\n## Concurrent Collections\n\n### ConcurrentDictionary\n\n```csharp\nprivate static readonly ConcurrentDictionary<int, ProcessingState> _processing = new();\n\npublic bool TryStartProcessing(int docId)\n{\n    return _processing.TryAdd(docId, new ProcessingState\n    {\n        StartedAt = DateTime.UtcNow,\n        ThreadId = Thread.CurrentThread.ManagedThreadId\n    });\n}\n\npublic void FinishProcessing(int docId)\n{\n    _processing.TryRemove(docId, out _);\n}\n```\n\n### ConcurrentQueue für Task-Verteilung\n\n```csharp\nprivate static readonly ConcurrentQueue<DocumentTask> _taskQueue = new();\n\npublic void EnqueueTask(DocumentTask task)\n{\n    _taskQueue.Enqueue(task);\n}\n\npublic void ProcessQueue()\n{\n    while (_taskQueue.TryDequeue(out var task))\n    {\n        AttachThreadToClarion(1);\n        try\n        {\n            ProcessTask(task);\n        }\n        finally\n        {\n            DetachThreadFromClarion();\n        }\n    }\n}\n```\n\n## Parallel Processing Muster\n\n### Parallel.ForEach mit Clarion\n\n```csharp\npublic void ProcessDocumentsBatch(List<int> documentIds)\n{\n    var options = new ParallelOptions\n    {\n        MaxDegreeOfParallelism = 4 // Threads begrenzen\n    };\n    \n    Parallel.ForEach(documentIds, options, docId =>\n    {\n        AttachThreadToClarion(1);\n        try\n        {\n            ProcessSingleDocument(docId);\n        }\n        catch (Exception ex)\n        {\n            _logger.Error(ex, $\"Dokument {docId} konnte nicht verarbeitet werden\");\n        }\n        finally\n        {\n            DetachThreadFromClarion();\n        }\n    });\n}\n```\n\n## Deadlock-Prävention\n\n### Lock-Reihenfolge\n\n```csharp\n// FALSCH - Kann deadlocken\npublic void Transfer(Account from, Account to, decimal amount)\n{\n    lock (from)\n    {\n        lock (to)\n        {\n            from.Balance -= amount;\n            to.Balance += amount;\n        }\n    }\n}\n\n// RICHTIG - Immer in gleicher Reihenfolge locken\npublic void Transfer(Account from, Account to, decimal amount)\n{\n    var first = from.Id < to.Id ? from : to;\n    var second = from.Id < to.Id ? to : from;\n    \n    lock (first)\n    {\n        lock (second)\n        {\n            from.Balance -= amount;\n            to.Balance += amount;\n        }\n    }\n}\n```\n\n### Timeout-Muster\n\n```csharp\npublic bool TryProcessWithTimeout(int docId, TimeSpan timeout)\n{\n    if (!Monitor.TryEnter(_lock, timeout))\n    {\n        _logger.Warn($\"Timeout beim Erwerben des Locks für Dokument {docId}\");\n        return false;\n    }\n    \n    try\n    {\n        ProcessDocument(docId);\n        return true;\n    }\n    finally\n    {\n        Monitor.Exit(_lock);\n    }\n}\n```\n\n## Testen von Race Conditions\n\n### Stresstest\n\n```csharp\n[Test]\npublic async Task StressTest_ConcurrentDocumentProcessing()\n{\n    const int threadCount = 10;\n    const int iterationsPerThread = 100;\n    var errors = new ConcurrentBag<Exception>();\n    \n    var tasks = Enumerable.Range(0, threadCount)\n        .Select(async i =>\n        {\n            for (int j = 0; j < iterationsPerThread; j++)\n            {\n                try\n                {\n                    await ProcessDocumentAsync(i * iterationsPerThread + j);\n                }\n                catch (Exception ex)\n                {\n                    errors.Add(ex);\n                }\n            }\n        });\n    \n    await Task.WhenAll(tasks);\n    \n    Assert.IsEmpty(errors, $\"{errors.Count} Fehler gefunden\");\n}\n```\n\n## Monitoring\n\n### Thread Pool Metriken\n\n```csharp\npublic class ThreadPoolMonitor\n{\n    public static void LogStatus()\n    {\n        ThreadPool.GetAvailableThreads(out var workerThreads, out var ioThreads);\n        ThreadPool.GetMaxThreads(out var maxWorkerThreads, out var maxIoThreads);\n        \n        _logger.Info($\"ThreadPool: {maxWorkerThreads - workerThreads}/{maxWorkerThreads} worker, \" +\n                     $\"{maxIoThreads - ioThreads}/{maxIoThreads} IO\");\n    }\n}\n```\n\n## Häufige Fehler\n\n1. **DetachThreadFromClarion vergessen** - Memory Leak\n2. **ERP-Objekte zwischen Threads teilen** - Korruption\n3. **Keine Locks für gemeinsamen Zustand** - Race Conditions\n4. **ThreadPool-Threads blockieren** - Starvation\n5. **Verschachtelte Locks ohne Reihenfolge** - Deadlocks\n\n## Production Checklist\n\n- ✅ Alle ERP-API-Aufrufe in Attach/Detach verpackt\n- ✅ Gemeinsamer Zustand durch Locks geschützt\n- ✅ Lock-Reihenfolge dokumentiert und durchgesetzt\n- ✅ Timeouts für Lock-Erwerb\n- ✅ Thread-Pool-Monitoring\n- ✅ Stresstests für Race Conditions\n- ✅ Exception-Handling in allen Threads"
}
