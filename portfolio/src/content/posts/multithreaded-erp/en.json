{
  "title": "Multi-threaded ERP Automation - Avoiding Race Conditions",
  "summary": "Practical patterns for thread-safe ERP automation with AttachThreadToClarion and proper synchronization.",
  "content": "## Introduction\n\nERP systems like Comarch XL use Clarion runtime which requires specific thread management. Improper handling leads to race conditions, data corruption, and access violations. This article shows proven patterns from production systems.\n\n## The Problem\n\n### Race Condition Example\n\n```csharp\n// WRONG - Race condition\nprivate static int _documentCounter = 0;\n\npublic void ProcessDocument()\n{\n    _documentCounter++; // Not thread-safe!\n    var docNumber = _documentCounter;\n    SaveDocument(docNumber);\n}\n```\n\nMultiple threads incrementing counter simultaneously:\n- Thread A reads 100\n- Thread B reads 100\n- Thread A writes 101\n- Thread B writes 101 (should be 102!)\n\n## AttachThreadToClarion Pattern\n\n### Why It's Needed\n\nClarion runtime uses thread-local storage. Every API call must run on attached thread:\n\n```csharp\npublic void ProcessInBackground()\n{\n    Task.Run(() =>\n    {\n        // WRONG - Access violation!\n        var doc = GetDocument();\n    });\n}\n```\n\n### Correct Pattern\n\n```csharp\npublic void ProcessInBackground()\n{\n    Task.Run(() =>\n    {\n        AttachThreadToClarion(1);\n        try\n        {\n            var doc = GetDocument();\n            ProcessDocument(doc);\n        }\n        finally\n        {\n            DetachThreadFromClarion();\n        }\n    });\n}\n```\n\n## Thread Synchronization\n\n### Lock Pattern\n\n```csharp\nprivate static readonly object _lock = new object();\nprivate static Dictionary<int, DocumentState> _states = new();\n\npublic void UpdateDocumentState(int docId, DocumentState state)\n{\n    lock (_lock)\n    {\n        _states[docId] = state;\n    }\n}\n\npublic DocumentState GetDocumentState(int docId)\n{\n    lock (_lock)\n    {\n        return _states.TryGetValue(docId, out var state) \n            ? state \n            : DocumentState.Unknown;\n    }\n}\n```\n\n### SemaphoreSlim for Async\n\n```csharp\nprivate static readonly SemaphoreSlim _semaphore = new(1, 1);\n\npublic async Task UpdateDocumentAsync(int docId)\n{\n    await _semaphore.WaitAsync();\n    try\n    {\n        AttachThreadToClarion(1);\n        try\n        {\n            var doc = GetDocument(docId);\n            await ProcessDocumentAsync(doc);\n        }\n        finally\n        {\n            DetachThreadFromClarion();\n        }\n    }\n    finally\n    {\n        _semaphore.Release();\n    }\n}\n```\n\n## Session Isolation\n\n### Session-Per-Thread Pattern\n\n```csharp\nprivate static readonly ThreadLocal<SessionContext> _sessionContext = \n    new ThreadLocal<SessionContext>(() => new SessionContext());\n\npublic void ProcessDocument()\n{\n    AttachThreadToClarion(1);\n    try\n    {\n        var context = _sessionContext.Value;\n        context.SessionId = GetCurrentSessionId();\n        context.ThreadId = Thread.CurrentThread.ManagedThreadId;\n        \n        _logger.Info($\"Session {context.SessionId} on thread {context.ThreadId}\");\n        \n        ProcessWithContext(context);\n    }\n    finally\n    {\n        DetachThreadFromClarion();\n    }\n}\n```\n\n### Session Context Class\n\n```csharp\npublic class SessionContext\n{\n    public int SessionId { get; set; }\n    public int ThreadId { get; set; }\n    public DateTime StartTime { get; set; } = DateTime.UtcNow;\n    public Dictionary<string, object> Data { get; } = new();\n}\n```\n\n## Concurrent Collections\n\n### ConcurrentDictionary\n\n```csharp\nprivate static readonly ConcurrentDictionary<int, ProcessingState> _processing = new();\n\npublic bool TryStartProcessing(int docId)\n{\n    return _processing.TryAdd(docId, new ProcessingState\n    {\n        StartedAt = DateTime.UtcNow,\n        ThreadId = Thread.CurrentThread.ManagedThreadId\n    });\n}\n\npublic void FinishProcessing(int docId)\n{\n    _processing.TryRemove(docId, out _);\n}\n```\n\n### ConcurrentQueue for Task Distribution\n\n```csharp\nprivate static readonly ConcurrentQueue<DocumentTask> _taskQueue = new();\n\npublic void EnqueueTask(DocumentTask task)\n{\n    _taskQueue.Enqueue(task);\n}\n\npublic void ProcessQueue()\n{\n    while (_taskQueue.TryDequeue(out var task))\n    {\n        AttachThreadToClarion(1);\n        try\n        {\n            ProcessTask(task);\n        }\n        finally\n        {\n            DetachThreadFromClarion();\n        }\n    }\n}\n```\n\n## Parallel Processing Pattern\n\n### Parallel.ForEach with Clarion\n\n```csharp\npublic void ProcessDocumentsBatch(List<int> documentIds)\n{\n    var options = new ParallelOptions\n    {\n        MaxDegreeOfParallelism = 4 // Limit threads\n    };\n    \n    Parallel.ForEach(documentIds, options, docId =>\n    {\n        AttachThreadToClarion(1);\n        try\n        {\n            ProcessSingleDocument(docId);\n        }\n        catch (Exception ex)\n        {\n            _logger.Error(ex, $\"Failed to process document {docId}\");\n        }\n        finally\n        {\n            DetachThreadFromClarion();\n        }\n    });\n}\n```\n\n## Deadlock Prevention\n\n### Lock Ordering\n\n```csharp\n// WRONG - Can deadlock\npublic void Transfer(Account from, Account to, decimal amount)\n{\n    lock (from)\n    {\n        lock (to)\n        {\n            from.Balance -= amount;\n            to.Balance += amount;\n        }\n    }\n}\n\n// CORRECT - Always lock in same order\npublic void Transfer(Account from, Account to, decimal amount)\n{\n    var first = from.Id < to.Id ? from : to;\n    var second = from.Id < to.Id ? to : from;\n    \n    lock (first)\n    {\n        lock (second)\n        {\n            from.Balance -= amount;\n            to.Balance += amount;\n        }\n    }\n}\n```\n\n### Timeout Pattern\n\n```csharp\npublic bool TryProcessWithTimeout(int docId, TimeSpan timeout)\n{\n    if (!Monitor.TryEnter(_lock, timeout))\n    {\n        _logger.Warn($\"Timeout acquiring lock for document {docId}\");\n        return false;\n    }\n    \n    try\n    {\n        ProcessDocument(docId);\n        return true;\n    }\n    finally\n    {\n        Monitor.Exit(_lock);\n    }\n}\n```\n\n## Testing for Race Conditions\n\n### Stress Test\n\n```csharp\n[Test]\npublic async Task StressTest_ConcurrentDocumentProcessing()\n{\n    const int threadCount = 10;\n    const int iterationsPerThread = 100;\n    var errors = new ConcurrentBag<Exception>();\n    \n    var tasks = Enumerable.Range(0, threadCount)\n        .Select(async i =>\n        {\n            for (int j = 0; j < iterationsPerThread; j++)\n            {\n                try\n                {\n                    await ProcessDocumentAsync(i * iterationsPerThread + j);\n                }\n                catch (Exception ex)\n                {\n                    errors.Add(ex);\n                }\n            }\n        });\n    \n    await Task.WhenAll(tasks);\n    \n    Assert.IsEmpty(errors, $\"Found {errors.Count} errors\");\n}\n```\n\n## Monitoring\n\n### Thread Pool Metrics\n\n```csharp\npublic class ThreadPoolMonitor\n{\n    public static void LogStatus()\n    {\n        ThreadPool.GetAvailableThreads(out var workerThreads, out var ioThreads);\n        ThreadPool.GetMaxThreads(out var maxWorkerThreads, out var maxIoThreads);\n        \n        _logger.Info($\"ThreadPool: {maxWorkerThreads - workerThreads}/{maxWorkerThreads} worker, \" +\n                     $\"{maxIoThreads - ioThreads}/{maxIoThreads} IO\");\n    }\n}\n```\n\n## Common Pitfalls\n\n1. **Forgetting DetachThreadFromClarion** - memory leak\n2. **Sharing ERP objects between threads** - corruption\n3. **Not using locks for shared state** - race conditions\n4. **Blocking ThreadPool threads** - starvation\n5. **Nested locks without ordering** - deadlocks\n\n## Production Checklist\n\n- ✅ All ERP API calls wrapped in Attach/Detach\n- ✅ Shared state protected by locks\n- ✅ Lock ordering documented and enforced\n- ✅ Timeouts for lock acquisition\n- ✅ Thread pool monitoring\n- ✅ Stress tests for race conditions\n- ✅ Exception handling in all threads"
}
