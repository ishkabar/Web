{
  "title": "FTP-Synchronisierungsmuster - Retry-Logik und Fehlerbehandlung",
  "summary": "Bewährte Muster für zuverlässige FTP-Dateisynchronisierung mit Exponential Backoff und Konfliktlösung.",
  "content": "## Einführung\n\nFTP ist trotz 50 Jahren immer noch in ERP-Integrationen üblich. Netzwerkprobleme, Dateisperren und gleichzeitiger Zugriff machen zuverlässige Synchronisierung zur Herausforderung. Dieser Artikel zeigt kampferprobte Muster aus Produktionssystemen, die Millionen von Dateien verarbeiten.\n\n## Basis FTP-Client\n\n### FluentFTP Setup\n\n```csharp\npublic class FtpSyncService\n{\n    private readonly ILogger _logger;\n    private readonly FtpConfig _config;\n    \n    public async Task<FtpClient> CreateClientAsync()\n    {\n        var client = new FtpClient\n        {\n            Host = _config.Host,\n            Port = _config.Port,\n            Credentials = new NetworkCredential(\n                _config.Username, \n                _config.Password),\n            Config = new FtpConfig\n            {\n                EncryptionMode = FtpEncryptionMode.Auto,\n                ValidateAnyCertificate = true,\n                ConnectTimeout = 10000,\n                DataConnectionType = FtpDataConnectionType.PASV\n            }\n        };\n        \n        await client.AutoConnectAsync();\n        return client;\n    }\n}\n```\n\n## Retry mit Exponential Backoff\n\n### Polly Policy\n\n```csharp\nprivate static readonly AsyncRetryPolicy _retryPolicy = Policy\n    .Handle<FtpException>()\n    .Or<TimeoutException>()\n    .Or<IOException>()\n    .WaitAndRetryAsync(\n        retryCount: 5,\n        sleepDurationProvider: attempt => \n            TimeSpan.FromSeconds(Math.Pow(2, attempt)),\n        onRetry: (exception, timeSpan, attempt, context) =>\n        {\n            _logger.Warn($\"Versuch {attempt} nach {timeSpan.TotalSeconds}s: {exception.Message}\");\n        });\n\npublic async Task<bool> UploadWithRetryAsync(string localPath, string remotePath)\n{\n    return await _retryPolicy.ExecuteAsync(async () =>\n    {\n        using var client = await CreateClientAsync();\n        var result = await client.UploadFileAsync(\n            localPath, \n            remotePath,\n            FtpRemoteExists.Overwrite);\n        \n        return result == FtpStatus.Success;\n    });\n}\n```\n\n### Eigene Retry-Logik\n\n```csharp\npublic async Task<T> ExecuteWithRetryAsync<T>(\n    Func<Task<T>> operation,\n    int maxAttempts = 5)\n{\n    var delays = new[] { 1, 2, 4, 8, 16 }; // Sekunden\n    \n    for (int attempt = 1; attempt <= maxAttempts; attempt++)\n    {\n        try\n        {\n            return await operation();\n        }\n        catch (Exception ex) when (attempt < maxAttempts)\n        {\n            var delay = TimeSpan.FromSeconds(delays[attempt - 1]);\n            _logger.Warn($\"Versuch {attempt} fehlgeschlagen: {ex.Message}. Wiederholung in {delay.TotalSeconds}s\");\n            await Task.Delay(delay);\n        }\n    }\n    \n    throw new InvalidOperationException($\"Operation nach {maxAttempts} Versuchen fehlgeschlagen\");\n}\n```\n\n## Dateisperren-Handling\n\n### Prüfen ob Datei gesperrt ist\n\n```csharp\nprivate async Task<bool> IsFileLockedAsync(FtpClient client, string remotePath)\n{\n    try\n    {\n        // Umbenennung versuchen - schlägt fehl wenn gesperrt\n        var tempName = $\"{remotePath}.lock_check\";\n        await client.RenameAsync(remotePath, tempName);\n        await client.RenameAsync(tempName, remotePath);\n        return false;\n    }\n    catch (FtpException)\n    {\n        return true;\n    }\n}\n\npublic async Task WaitForFileUnlockAsync(\n    FtpClient client, \n    string remotePath,\n    TimeSpan maxWait)\n{\n    var stopwatch = Stopwatch.StartNew();\n    \n    while (stopwatch.Elapsed < maxWait)\n    {\n        if (!await IsFileLockedAsync(client, remotePath))\n            return;\n        \n        await Task.Delay(1000);\n    }\n    \n    throw new TimeoutException($\"Datei {remotePath} blieb gesperrt für {maxWait}\");\n}\n```\n\n## Partielles Download-Resume\n\n### Download fortsetzen\n\n```csharp\npublic async Task<bool> DownloadWithResumeAsync(\n    string remotePath,\n    string localPath)\n{\n    using var client = await CreateClientAsync();\n    \n    var remoteSize = await client.GetFileSizeAsync(remotePath);\n    var localSize = File.Exists(localPath) ? new FileInfo(localPath).Length : 0;\n    \n    if (localSize == remoteSize)\n    {\n        _logger.Info($\"Datei {remotePath} bereits heruntergeladen\");\n        return true;\n    }\n    \n    if (localSize > 0 && localSize < remoteSize)\n    {\n        _logger.Info($\"Download fortsetzen ab Byte {localSize}\");\n        \n        using var fileStream = new FileStream(\n            localPath, \n            FileMode.Append, \n            FileAccess.Write);\n        \n        await client.DownloadStreamAsync(\n            fileStream,\n            remotePath,\n            localSize); // Startposition\n    }\n    else\n    {\n        await client.DownloadFileAsync(\n            localPath,\n            remotePath,\n            FtpLocalExists.Overwrite);\n    }\n    \n    return true;\n}\n```\n\n## Atomares Upload-Muster\n\n### Upload zu Temp, dann Umbenennen\n\n```csharp\npublic async Task<bool> UploadAtomicAsync(\n    string localPath,\n    string remotePath)\n{\n    using var client = await CreateClientAsync();\n    \n    var tempPath = $\"{remotePath}.tmp\";\n    \n    try\n    {\n        // Upload zur temporären Datei\n        await client.UploadFileAsync(\n            localPath,\n            tempPath,\n            FtpRemoteExists.Overwrite);\n        \n        // Upload verifizieren\n        var localSize = new FileInfo(localPath).Length;\n        var remoteSize = await client.GetFileSizeAsync(tempPath);\n        \n        if (localSize != remoteSize)\n        {\n            throw new InvalidOperationException(\n                $\"Größenabweichung: local={localSize}, remote={remoteSize}\");\n        }\n        \n        // Atomare Umbenennung\n        if (await client.FileExistsAsync(remotePath))\n        {\n            await client.DeleteFileAsync(remotePath);\n        }\n        \n        await client.RenameAsync(tempPath, remotePath);\n        \n        return true;\n    }\n    catch\n    {\n        // Temp-Datei bei Fehler aufräumen\n        if (await client.FileExistsAsync(tempPath))\n        {\n            await client.DeleteFileAsync(tempPath);\n        }\n        throw;\n    }\n}\n```\n\n## Verzeichnissynchronisierung\n\n### Remote zu Local synchronisieren\n\n```csharp\npublic async Task SyncDirectoryAsync(\n    string remotePath,\n    string localPath)\n{\n    using var client = await CreateClientAsync();\n    \n    var remoteFiles = await client.GetListingAsync(remotePath);\n    var localFiles = Directory.GetFiles(localPath)\n        .Select(f => Path.GetFileName(f))\n        .ToHashSet();\n    \n    foreach (var remoteFile in remoteFiles.Where(f => f.Type == FtpObjectType.File))\n    {\n        var remoteFilePath = remoteFile.FullName;\n        var localFilePath = Path.Combine(localPath, remoteFile.Name);\n        \n        var shouldDownload = !File.Exists(localFilePath) ||\n            remoteFile.Modified > File.GetLastWriteTimeUtc(localFilePath);\n        \n        if (shouldDownload)\n        {\n            _logger.Info($\"Herunterladen {remoteFile.Name}\");\n            await DownloadWithResumeAsync(remoteFilePath, localFilePath);\n        }\n        \n        localFiles.Remove(remoteFile.Name);\n    }\n    \n    // Lokale Dateien löschen, die nicht auf Remote sind\n    foreach (var orphanFile in localFiles)\n    {\n        var localFilePath = Path.Combine(localPath, orphanFile);\n        _logger.Info($\"Verwaiste Datei löschen {orphanFile}\");\n        File.Delete(localFilePath);\n    }\n}\n```\n\n## Konfliktlösung\n\n### Timestamp-basiert\n\n```csharp\npublic async Task<ConflictResolution> ResolveConflictAsync(\n    FtpClient client,\n    string remotePath,\n    string localPath)\n{\n    var remoteModified = await client.GetModifiedTimeAsync(remotePath);\n    var localModified = File.GetLastWriteTimeUtc(localPath);\n    \n    if (remoteModified > localModified)\n    {\n        return ConflictResolution.UseRemote;\n    }\n    else if (localModified > remoteModified)\n    {\n        return ConflictResolution.UseLocal;\n    }\n    \n    // Gleicher Timestamp - Größe vergleichen\n    var remoteSize = await client.GetFileSizeAsync(remotePath);\n    var localSize = new FileInfo(localPath).Length;\n    \n    return remoteSize == localSize \n        ? ConflictResolution.Identical \n        : ConflictResolution.Manual;\n}\n```\n\n## Monitoring und Logging\n\n### Transfer-Fortschritt\n\n```csharp\npublic async Task UploadWithProgressAsync(\n    string localPath,\n    string remotePath,\n    IProgress<FtpProgress> progress)\n{\n    using var client = await CreateClientAsync();\n    \n    var result = await client.UploadFileAsync(\n        localPath,\n        remotePath,\n        FtpRemoteExists.Overwrite,\n        progress: progress);\n    \n    if (result != FtpStatus.Success)\n    {\n        throw new InvalidOperationException($\"Upload fehlgeschlagen: {result}\");\n    }\n}\n\npublic async Task UploadBatchWithReportingAsync(List<string> files)\n{\n    var progress = new Progress<FtpProgress>(p =>\n    {\n        _logger.Info($\"Fortschritt: {p.Progress:P} ({p.TransferredBytes}/{p.FileSize} Bytes)\");\n    });\n    \n    foreach (var file in files)\n    {\n        await UploadWithProgressAsync(file, $\"/upload/{Path.GetFileName(file)}\", progress);\n    }\n}\n```\n\n## Connection Pooling\n\n### Einfacher Pool\n\n```csharp\npublic class FtpConnectionPool : IDisposable\n{\n    private readonly ConcurrentBag<FtpClient> _pool = new();\n    private readonly SemaphoreSlim _semaphore;\n    private readonly int _maxSize;\n    \n    public FtpConnectionPool(int maxSize = 5)\n    {\n        _maxSize = maxSize;\n        _semaphore = new SemaphoreSlim(maxSize, maxSize);\n    }\n    \n    public async Task<FtpClient> RentAsync()\n    {\n        await _semaphore.WaitAsync();\n        \n        if (_pool.TryTake(out var client) && client.IsConnected)\n        {\n            return client;\n        }\n        \n        return await CreateClientAsync();\n    }\n    \n    public void Return(FtpClient client)\n    {\n        if (client.IsConnected && _pool.Count < _maxSize)\n        {\n            _pool.Add(client);\n        }\n        else\n        {\n            client.Dispose();\n        }\n        \n        _semaphore.Release();\n    }\n    \n    public void Dispose()\n    {\n        while (_pool.TryTake(out var client))\n        {\n            client.Dispose();\n        }\n        _semaphore.Dispose();\n    }\n}\n```\n\n## Production Checklist\n\n- ✅ Retry-Logik mit Exponential Backoff (1s, 2s, 4s, 8s, 16s)\n- ✅ Dateisperren-Erkennung und Warten\n- ✅ Partielles Download-Resume für große Dateien\n- ✅ Atomare Uploads (temp + rename)\n- ✅ Konfliktlösungsstrategie\n- ✅ Connection Pooling für Performance\n- ✅ Fortschrittsberichterstattung und Monitoring\n- ✅ Umfassendes Fehler-Logging\n- ✅ Aufräumen temporärer Dateien\n- ✅ Timeout-Konfiguration"
}