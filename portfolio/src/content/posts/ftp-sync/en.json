{
  "title": "FTP Synchronization Patterns - Retry Logic and Error Handling",
  "summary": "Production-proven patterns for reliable FTP file synchronization with exponential backoff and conflict resolution.",
  "content": "## Introduction\n\nFTP remains common in ERP integrations despite being 50 years old. Network issues, file locks, and concurrent access make reliable synchronization challenging. This article shows battle-tested patterns from production systems processing millions of files.\n\n## Basic FTP Client\n\n### FluentFTP Setup\n\n```csharp\npublic class FtpSyncService\n{\n    private readonly ILogger _logger;\n    private readonly FtpConfig _config;\n    \n    public async Task<FtpClient> CreateClientAsync()\n    {\n        var client = new FtpClient\n        {\n            Host = _config.Host,\n            Port = _config.Port,\n            Credentials = new NetworkCredential(\n                _config.Username, \n                _config.Password),\n            Config = new FtpConfig\n            {\n                EncryptionMode = FtpEncryptionMode.Auto,\n                ValidateAnyCertificate = true,\n                ConnectTimeout = 10000,\n                DataConnectionType = FtpDataConnectionType.PASV\n            }\n        };\n        \n        await client.AutoConnectAsync();\n        return client;\n    }\n}\n```\n\n## Retry with Exponential Backoff\n\n### Polly Policy\n\n```csharp\nprivate static readonly AsyncRetryPolicy _retryPolicy = Policy\n    .Handle<FtpException>()\n    .Or<TimeoutException>()\n    .Or<IOException>()\n    .WaitAndRetryAsync(\n        retryCount: 5,\n        sleepDurationProvider: attempt => \n            TimeSpan.FromSeconds(Math.Pow(2, attempt)),\n        onRetry: (exception, timeSpan, attempt, context) =>\n        {\n            _logger.Warn($\"Retry {attempt} after {timeSpan.TotalSeconds}s: {exception.Message}\");\n        });\n\npublic async Task<bool> UploadWithRetryAsync(string localPath, string remotePath)\n{\n    return await _retryPolicy.ExecuteAsync(async () =>\n    {\n        using var client = await CreateClientAsync();\n        var result = await client.UploadFileAsync(\n            localPath, \n            remotePath,\n            FtpRemoteExists.Overwrite);\n        \n        return result == FtpStatus.Success;\n    });\n}\n```\n\n### Custom Retry Logic\n\n```csharp\npublic async Task<T> ExecuteWithRetryAsync<T>(\n    Func<Task<T>> operation,\n    int maxAttempts = 5)\n{\n    var delays = new[] { 1, 2, 4, 8, 16 }; // seconds\n    \n    for (int attempt = 1; attempt <= maxAttempts; attempt++)\n    {\n        try\n        {\n            return await operation();\n        }\n        catch (Exception ex) when (attempt < maxAttempts)\n        {\n            var delay = TimeSpan.FromSeconds(delays[attempt - 1]);\n            _logger.Warn($\"Attempt {attempt} failed: {ex.Message}. Retrying in {delay.TotalSeconds}s\");\n            await Task.Delay(delay);\n        }\n    }\n    \n    throw new InvalidOperationException($\"Operation failed after {maxAttempts} attempts\");\n}\n```\n\n## File Lock Handling\n\n### Check if File is Locked\n\n```csharp\nprivate async Task<bool> IsFileLockedAsync(FtpClient client, string remotePath)\n{\n    try\n    {\n        // Try to rename - if locked, will fail\n        var tempName = $\"{remotePath}.lock_check\";\n        await client.RenameAsync(remotePath, tempName);\n        await client.RenameAsync(tempName, remotePath);\n        return false;\n    }\n    catch (FtpException)\n    {\n        return true;\n    }\n}\n\npublic async Task WaitForFileUnlockAsync(\n    FtpClient client, \n    string remotePath,\n    TimeSpan maxWait)\n{\n    var stopwatch = Stopwatch.StartNew();\n    \n    while (stopwatch.Elapsed < maxWait)\n    {\n        if (!await IsFileLockedAsync(client, remotePath))\n            return;\n        \n        await Task.Delay(1000);\n    }\n    \n    throw new TimeoutException($\"File {remotePath} remained locked for {maxWait}\");\n}\n```\n\n## Partial Download Resume\n\n### Resume Download\n\n```csharp\npublic async Task<bool> DownloadWithResumeAsync(\n    string remotePath,\n    string localPath)\n{\n    using var client = await CreateClientAsync();\n    \n    var remoteSize = await client.GetFileSizeAsync(remotePath);\n    var localSize = File.Exists(localPath) ? new FileInfo(localPath).Length : 0;\n    \n    if (localSize == remoteSize)\n    {\n        _logger.Info($\"File {remotePath} already downloaded\");\n        return true;\n    }\n    \n    if (localSize > 0 && localSize < remoteSize)\n    {\n        _logger.Info($\"Resuming download from byte {localSize}\");\n        \n        using var fileStream = new FileStream(\n            localPath, \n            FileMode.Append, \n            FileAccess.Write);\n        \n        await client.DownloadStreamAsync(\n            fileStream,\n            remotePath,\n            localSize); // start position\n    }\n    else\n    {\n        await client.DownloadFileAsync(\n            localPath,\n            remotePath,\n            FtpLocalExists.Overwrite);\n    }\n    \n    return true;\n}\n```\n\n## Atomic Upload Pattern\n\n### Upload to Temp, Then Rename\n\n```csharp\npublic async Task<bool> UploadAtomicAsync(\n    string localPath,\n    string remotePath)\n{\n    using var client = await CreateClientAsync();\n    \n    var tempPath = $\"{remotePath}.tmp\";\n    \n    try\n    {\n        // Upload to temporary file\n        await client.UploadFileAsync(\n            localPath,\n            tempPath,\n            FtpRemoteExists.Overwrite);\n        \n        // Verify upload\n        var localSize = new FileInfo(localPath).Length;\n        var remoteSize = await client.GetFileSizeAsync(tempPath);\n        \n        if (localSize != remoteSize)\n        {\n            throw new InvalidOperationException(\n                $\"Size mismatch: local={localSize}, remote={remoteSize}\");\n        }\n        \n        // Atomic rename\n        if (await client.FileExistsAsync(remotePath))\n        {\n            await client.DeleteFileAsync(remotePath);\n        }\n        \n        await client.RenameAsync(tempPath, remotePath);\n        \n        return true;\n    }\n    catch\n    {\n        // Cleanup temp file on failure\n        if (await client.FileExistsAsync(tempPath))\n        {\n            await client.DeleteFileAsync(tempPath);\n        }\n        throw;\n    }\n}\n```\n\n## Directory Synchronization\n\n### Sync Remote to Local\n\n```csharp\npublic async Task SyncDirectoryAsync(\n    string remotePath,\n    string localPath)\n{\n    using var client = await CreateClientAsync();\n    \n    var remoteFiles = await client.GetListingAsync(remotePath);\n    var localFiles = Directory.GetFiles(localPath)\n        .Select(f => Path.GetFileName(f))\n        .ToHashSet();\n    \n    foreach (var remoteFile in remoteFiles.Where(f => f.Type == FtpObjectType.File))\n    {\n        var remoteFilePath = remoteFile.FullName;\n        var localFilePath = Path.Combine(localPath, remoteFile.Name);\n        \n        var shouldDownload = !File.Exists(localFilePath) ||\n            remoteFile.Modified > File.GetLastWriteTimeUtc(localFilePath);\n        \n        if (shouldDownload)\n        {\n            _logger.Info($\"Downloading {remoteFile.Name}\");\n            await DownloadWithResumeAsync(remoteFilePath, localFilePath);\n        }\n        \n        localFiles.Remove(remoteFile.Name);\n    }\n    \n    // Delete local files not on remote\n    foreach (var orphanFile in localFiles)\n    {\n        var localFilePath = Path.Combine(localPath, orphanFile);\n        _logger.Info($\"Deleting orphan file {orphanFile}\");\n        File.Delete(localFilePath);\n    }\n}\n```\n\n## Conflict Resolution\n\n### Timestamp-Based\n\n```csharp\npublic async Task<ConflictResolution> ResolveConflictAsync(\n    FtpClient client,\n    string remotePath,\n    string localPath)\n{\n    var remoteModified = await client.GetModifiedTimeAsync(remotePath);\n    var localModified = File.GetLastWriteTimeUtc(localPath);\n    \n    if (remoteModified > localModified)\n    {\n        return ConflictResolution.UseRemote;\n    }\n    else if (localModified > remoteModified)\n    {\n        return ConflictResolution.UseLocal;\n    }\n    \n    // Same timestamp - compare size\n    var remoteSize = await client.GetFileSizeAsync(remotePath);\n    var localSize = new FileInfo(localPath).Length;\n    \n    return remoteSize == localSize \n        ? ConflictResolution.Identical \n        : ConflictResolution.Manual;\n}\n```\n\n## Monitoring and Logging\n\n### Transfer Progress\n\n```csharp\npublic async Task UploadWithProgressAsync(\n    string localPath,\n    string remotePath,\n    IProgress<FtpProgress> progress)\n{\n    using var client = await CreateClientAsync();\n    \n    var result = await client.UploadFileAsync(\n        localPath,\n        remotePath,\n        FtpRemoteExists.Overwrite,\n        progress: progress);\n    \n    if (result != FtpStatus.Success)\n    {\n        throw new InvalidOperationException($\"Upload failed: {result}\");\n    }\n}\n\npublic async Task UploadBatchWithReportingAsync(List<string> files)\n{\n    var progress = new Progress<FtpProgress>(p =>\n    {\n        _logger.Info($\"Progress: {p.Progress:P} ({p.TransferredBytes}/{p.FileSize} bytes)\");\n    });\n    \n    foreach (var file in files)\n    {\n        await UploadWithProgressAsync(file, $\"/upload/{Path.GetFileName(file)}\", progress);\n    }\n}\n```\n\n## Connection Pooling\n\n### Simple Pool\n\n```csharp\npublic class FtpConnectionPool : IDisposable\n{\n    private readonly ConcurrentBag<FtpClient> _pool = new();\n    private readonly SemaphoreSlim _semaphore;\n    private readonly int _maxSize;\n    \n    public FtpConnectionPool(int maxSize = 5)\n    {\n        _maxSize = maxSize;\n        _semaphore = new SemaphoreSlim(maxSize, maxSize);\n    }\n    \n    public async Task<FtpClient> RentAsync()\n    {\n        await _semaphore.WaitAsync();\n        \n        if (_pool.TryTake(out var client) && client.IsConnected)\n        {\n            return client;\n        }\n        \n        return await CreateClientAsync();\n    }\n    \n    public void Return(FtpClient client)\n    {\n        if (client.IsConnected && _pool.Count < _maxSize)\n        {\n            _pool.Add(client);\n        }\n        else\n        {\n            client.Dispose();\n        }\n        \n        _semaphore.Release();\n    }\n    \n    public void Dispose()\n    {\n        while (_pool.TryTake(out var client))\n        {\n            client.Dispose();\n        }\n        _semaphore.Dispose();\n    }\n}\n```\n\n## Production Checklist\n\n- ✅ Retry logic with exponential backoff (1s, 2s, 4s, 8s, 16s)\n- ✅ File lock detection and waiting\n- ✅ Partial download resume for large files\n- ✅ Atomic uploads (temp + rename)\n- ✅ Conflict resolution strategy\n- ✅ Connection pooling for performance\n- ✅ Progress reporting and monitoring\n- ✅ Comprehensive error logging\n- ✅ Cleanup of temporary files\n- ✅ Timeout configuration"
}
