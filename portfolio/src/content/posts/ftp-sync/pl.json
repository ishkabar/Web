{
  "title": "Wzorce Synchronizacji FTP - Retry Logic i Obsługa Błędów",
  "summary": "Sprawdzone wzorce niezawodnej synchronizacji plików FTP z exponential backoff i rozwiązywaniem konfliktów.",
  "content": "## Wprowadzenie\n\nFTP pozostaje powszechny w integracjach ERP pomimo 50 lat. Problemy sieciowe, blokady plików i współbieżny dostęp sprawiają, że niezawodna synchronizacja jest wyzwaniem. Ten artykuł pokazuje sprawdzone wzorce z systemów produkcyjnych przetwarzających miliony plików.\n\n## Podstawowy Klient FTP\n\n### Konfiguracja FluentFTP\n\n```csharp\npublic class FtpSyncService\n{\n    private readonly ILogger _logger;\n    private readonly FtpConfig _config;\n    \n    public async Task<FtpClient> CreateClientAsync()\n    {\n        var client = new FtpClient\n        {\n            Host = _config.Host,\n            Port = _config.Port,\n            Credentials = new NetworkCredential(\n                _config.Username, \n                _config.Password),\n            Config = new FtpConfig\n            {\n                EncryptionMode = FtpEncryptionMode.Auto,\n                ValidateAnyCertificate = true,\n                ConnectTimeout = 10000,\n                DataConnectionType = FtpDataConnectionType.PASV\n            }\n        };\n        \n        await client.AutoConnectAsync();\n        return client;\n    }\n}\n```\n\n## Retry z Exponential Backoff\n\n### Polly Policy\n\n```csharp\nprivate static readonly AsyncRetryPolicy _retryPolicy = Policy\n    .Handle<FtpException>()\n    .Or<TimeoutException>()\n    .Or<IOException>()\n    .WaitAndRetryAsync(\n        retryCount: 5,\n        sleepDurationProvider: attempt => \n            TimeSpan.FromSeconds(Math.Pow(2, attempt)),\n        onRetry: (exception, timeSpan, attempt, context) =>\n        {\n            _logger.Warn($\"Próba {attempt} po {timeSpan.TotalSeconds}s: {exception.Message}\");\n        });\n\npublic async Task<bool> UploadWithRetryAsync(string localPath, string remotePath)\n{\n    return await _retryPolicy.ExecuteAsync(async () =>\n    {\n        using var client = await CreateClientAsync();\n        var result = await client.UploadFileAsync(\n            localPath, \n            remotePath,\n            FtpRemoteExists.Overwrite);\n        \n        return result == FtpStatus.Success;\n    });\n}\n```\n\n### Własna Logika Retry\n\n```csharp\npublic async Task<T> ExecuteWithRetryAsync<T>(\n    Func<Task<T>> operation,\n    int maxAttempts = 5)\n{\n    var delays = new[] { 1, 2, 4, 8, 16 }; // sekundy\n    \n    for (int attempt = 1; attempt <= maxAttempts; attempt++)\n    {\n        try\n        {\n            return await operation();\n        }\n        catch (Exception ex) when (attempt < maxAttempts)\n        {\n            var delay = TimeSpan.FromSeconds(delays[attempt - 1]);\n            _logger.Warn($\"Próba {attempt} nieudana: {ex.Message}. Ponowienie za {delay.TotalSeconds}s\");\n            await Task.Delay(delay);\n        }\n    }\n    \n    throw new InvalidOperationException($\"Operacja nieudana po {maxAttempts} próbach\");\n}\n```\n\n## Obsługa Blokad Plików\n\n### Sprawdzenie czy Plik jest Zablokowany\n\n```csharp\nprivate async Task<bool> IsFileLockedAsync(FtpClient client, string remotePath)\n{\n    try\n    {\n        // Próba zmiany nazwy - jeśli zablokowany, operacja się nie powiedzie\n        var tempName = $\"{remotePath}.lock_check\";\n        await client.RenameAsync(remotePath, tempName);\n        await client.RenameAsync(tempName, remotePath);\n        return false;\n    }\n    catch (FtpException)\n    {\n        return true;\n    }\n}\n\npublic async Task WaitForFileUnlockAsync(\n    FtpClient client, \n    string remotePath,\n    TimeSpan maxWait)\n{\n    var stopwatch = Stopwatch.StartNew();\n    \n    while (stopwatch.Elapsed < maxWait)\n    {\n        if (!await IsFileLockedAsync(client, remotePath))\n            return;\n        \n        await Task.Delay(1000);\n    }\n    \n    throw new TimeoutException($\"Plik {remotePath} pozostał zablokowany przez {maxWait}\");\n}\n```\n\n## Wznawianie Częściowego Pobierania\n\n### Resume Download\n\n```csharp\npublic async Task<bool> DownloadWithResumeAsync(\n    string remotePath,\n    string localPath)\n{\n    using var client = await CreateClientAsync();\n    \n    var remoteSize = await client.GetFileSizeAsync(remotePath);\n    var localSize = File.Exists(localPath) ? new FileInfo(localPath).Length : 0;\n    \n    if (localSize == remoteSize)\n    {\n        _logger.Info($\"Plik {remotePath} już pobrany\");\n        return true;\n    }\n    \n    if (localSize > 0 && localSize < remoteSize)\n    {\n        _logger.Info($\"Wznawianie pobierania od bajtu {localSize}\");\n        \n        using var fileStream = new FileStream(\n            localPath, \n            FileMode.Append, \n            FileAccess.Write);\n        \n        await client.DownloadStreamAsync(\n            fileStream,\n            remotePath,\n            localSize); // pozycja startowa\n    }\n    else\n    {\n        await client.DownloadFileAsync(\n            localPath,\n            remotePath,\n            FtpLocalExists.Overwrite);\n    }\n    \n    return true;\n}\n```\n\n## Wzorzec Atomowego Uploadu\n\n### Upload do Temp, Potem Rename\n\n```csharp\npublic async Task<bool> UploadAtomicAsync(\n    string localPath,\n    string remotePath)\n{\n    using var client = await CreateClientAsync();\n    \n    var tempPath = $\"{remotePath}.tmp\";\n    \n    try\n    {\n        // Upload do pliku tymczasowego\n        await client.UploadFileAsync(\n            localPath,\n            tempPath,\n            FtpRemoteExists.Overwrite);\n        \n        // Weryfikacja uploadu\n        var localSize = new FileInfo(localPath).Length;\n        var remoteSize = await client.GetFileSizeAsync(tempPath);\n        \n        if (localSize != remoteSize)\n        {\n            throw new InvalidOperationException(\n                $\"Niezgodność rozmiaru: local={localSize}, remote={remoteSize}\");\n        }\n        \n        // Atomowa zmiana nazwy\n        if (await client.FileExistsAsync(remotePath))\n        {\n            await client.DeleteFileAsync(remotePath);\n        }\n        \n        await client.RenameAsync(tempPath, remotePath);\n        \n        return true;\n    }\n    catch\n    {\n        // Czyszczenie pliku temp przy błędzie\n        if (await client.FileExistsAsync(tempPath))\n        {\n            await client.DeleteFileAsync(tempPath);\n        }\n        throw;\n    }\n}\n```\n\n## Synchronizacja Katalogów\n\n### Sync Remote do Local\n\n```csharp\npublic async Task SyncDirectoryAsync(\n    string remotePath,\n    string localPath)\n{\n    using var client = await CreateClientAsync();\n    \n    var remoteFiles = await client.GetListingAsync(remotePath);\n    var localFiles = Directory.GetFiles(localPath)\n        .Select(f => Path.GetFileName(f))\n        .ToHashSet();\n    \n    foreach (var remoteFile in remoteFiles.Where(f => f.Type == FtpObjectType.File))\n    {\n        var remoteFilePath = remoteFile.FullName;\n        var localFilePath = Path.Combine(localPath, remoteFile.Name);\n        \n        var shouldDownload = !File.Exists(localFilePath) ||\n            remoteFile.Modified > File.GetLastWriteTimeUtc(localFilePath);\n        \n        if (shouldDownload)\n        {\n            _logger.Info($\"Pobieranie {remoteFile.Name}\");\n            await DownloadWithResumeAsync(remoteFilePath, localFilePath);\n        }\n        \n        localFiles.Remove(remoteFile.Name);\n    }\n    \n    // Usuwanie lokalnych plików nieobecnych na remote\n    foreach (var orphanFile in localFiles)\n    {\n        var localFilePath = Path.Combine(localPath, orphanFile);\n        _logger.Info($\"Usuwanie osieroconych plików {orphanFile}\");\n        File.Delete(localFilePath);\n    }\n}\n```\n\n## Rozwiązywanie Konfliktów\n\n### Na Podstawie Timestamp\n\n```csharp\npublic async Task<ConflictResolution> ResolveConflictAsync(\n    FtpClient client,\n    string remotePath,\n    string localPath)\n{\n    var remoteModified = await client.GetModifiedTimeAsync(remotePath);\n    var localModified = File.GetLastWriteTimeUtc(localPath);\n    \n    if (remoteModified > localModified)\n    {\n        return ConflictResolution.UseRemote;\n    }\n    else if (localModified > remoteModified)\n    {\n        return ConflictResolution.UseLocal;\n    }\n    \n    // Ten sam timestamp - porównaj rozmiar\n    var remoteSize = await client.GetFileSizeAsync(remotePath);\n    var localSize = new FileInfo(localPath).Length;\n    \n    return remoteSize == localSize \n        ? ConflictResolution.Identical \n        : ConflictResolution.Manual;\n}\n```\n\n## Monitoring i Logowanie\n\n### Postęp Transferu\n\n```csharp\npublic async Task UploadWithProgressAsync(\n    string localPath,\n    string remotePath,\n    IProgress<FtpProgress> progress)\n{\n    using var client = await CreateClientAsync();\n    \n    var result = await client.UploadFileAsync(\n        localPath,\n        remotePath,\n        FtpRemoteExists.Overwrite,\n        progress: progress);\n    \n    if (result != FtpStatus.Success)\n    {\n        throw new InvalidOperationException($\"Upload nieudany: {result}\");\n    }\n}\n\npublic async Task UploadBatchWithReportingAsync(List<string> files)\n{\n    var progress = new Progress<FtpProgress>(p =>\n    {\n        _logger.Info($\"Postęp: {p.Progress:P} ({p.TransferredBytes}/{p.FileSize} bajtów)\");\n    });\n    \n    foreach (var file in files)\n    {\n        await UploadWithProgressAsync(file, $\"/upload/{Path.GetFileName(file)}\", progress);\n    }\n}\n```\n\n## Connection Pooling\n\n### Prosty Pool\n\n```csharp\npublic class FtpConnectionPool : IDisposable\n{\n    private readonly ConcurrentBag<FtpClient> _pool = new();\n    private readonly SemaphoreSlim _semaphore;\n    private readonly int _maxSize;\n    \n    public FtpConnectionPool(int maxSize = 5)\n    {\n        _maxSize = maxSize;\n        _semaphore = new SemaphoreSlim(maxSize, maxSize);\n    }\n    \n    public async Task<FtpClient> RentAsync()\n    {\n        await _semaphore.WaitAsync();\n        \n        if (_pool.TryTake(out var client) && client.IsConnected)\n        {\n            return client;\n        }\n        \n        return await CreateClientAsync();\n    }\n    \n    public void Return(FtpClient client)\n    {\n        if (client.IsConnected && _pool.Count < _maxSize)\n        {\n            _pool.Add(client);\n        }\n        else\n        {\n            client.Dispose();\n        }\n        \n        _semaphore.Release();\n    }\n    \n    public void Dispose()\n    {\n        while (_pool.TryTake(out var client))\n        {\n            client.Dispose();\n        }\n        _semaphore.Dispose();\n    }\n}\n```\n\n## Production Checklist\n\n- ✅ Retry logic z exponential backoff (1s, 2s, 4s, 8s, 16s)\n- ✅ Detekcja blokad plików i oczekiwanie\n- ✅ Wznawianie częściowego pobierania dla dużych plików\n- ✅ Atomowe uploady (temp + rename)\n- ✅ Strategia rozwiązywania konfliktów\n- ✅ Connection pooling dla wydajności\n- ✅ Raportowanie postępu i monitoring\n- ✅ Kompleksowe logowanie błędów\n- ✅ Czyszczenie plików tymczasowych\n- ✅ Konfiguracja timeoutów"
}