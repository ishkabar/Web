{
  "title": "AutostacjaSync - Dokumentensynchronisation mit Prestiž ERP",
  "summary": "Kritische Integrationsschicht für Automobilunternehmen: .NET 8 Worker Service zur Synchronisation von XML-Dokumenten aus Werkstattsystemen mit Prestiž ERP über Firebird-Stored-Procedures.",
  "content": "## Überblick\n\nAutostacjaSync ist ein produktiver Windows-Dienst, der die automatische Synchronisation von Geschäftsdokumenten zwischen externen Systemen (Autowerkstätten, Kfz-Großhändler) und Prestiž ERP ermöglicht. Das System verarbeitet Dutzende von XML-Dokumenttypen, verwaltet Vertragspartner in über 25 EU-Ländern, bearbeitet Dokumentenkorrekturen und gewährleistet Datenkonsistenz durch fortschrittliche Firebird-Stored-Procedures.\n\nHauptrolle: Eliminierung manueller Rechnungsübertragung, Automatisierung von Wareneingang, Synchronisation von Kontrahentendaten aus externen Quellen unter Wahrung der referenziellen Integrität und Eindeutigkeit im Buchhaltungssystem.\n\n## Geschäftlicher Kontext\n\n### Problem\n\nAutomobilunternehmen verwenden dedizierte Werkstattsysteme (externe XML-APIs), die Verkaufsdokumente generieren, aber die Hauptbuchhaltung und Lagerverwaltung erfolgt in Prestiž ERP (Firebird). Manuelle Übertragung:\n- Erzeugt Fehler in USt-IdNr., Preisen, Mengen\n- Verzögert Dokumentenrealisierung um Stunden\n- Erfordert doppelte Eingabe von Kontrahentendaten\n- Bearbeitet Korrekturen nicht automatisch\n\n### Lösung\n\nAutomatisierte Pipeline:\n1. Externe Systeme exportieren XML in Netzwerkverzeichnis\n2. AutostacjaSync erkennt, parst, validiert\n3. Intelligentes Kontrahenten-Mapping (Suche nach USt-IdNr., Neuanlage mit EU-USt-Behandlung)\n4. Import in URZZEWNAGL/URZZEWNPOZ-Puffer in Prestiž\n5. Prestiž-Benutzer realisiert importiertes Dokument mit einem Klick\n\n### Nutzen\n\n- **Null manuelle Arbeit** bei Standarddokumenten\n- **Fehlerelimination** bei USt-IdNr., Preisen, Namen\n- **Internationale Compliance** - automatisches EU-USt-Mapping (25 Länder)\n- **Korrekturbearbeitung** - intelligentes Zeilen-Mapping trotz ERP-Neuordnung\n- **Audit-Trail** - vollständige Historie für jedes Dokument in NLog-Protokollen\n\n## Technische Architektur\n\n### Clean Architecture + DDD Lite\n\n```\nDomain/\n  Abstractions/\n    IContractorProcedures.cs      - ARIT_AUTOSTACJA_ADD_CONTRACTOR-Vertrag\n    IItemProcedures.cs            - ARIT_AUTOSTACJA_ADD_ITEM\n    IExternalDocProcedures.cs     - URZZEWNAGL_ADD_10, URZZEWNPOZ_ADD_10\n  ValueObjects/\n    ContractorRef.cs              - USt-IdNr., Name, Adresse (unveränderlich)\n    ItemRef.cs                    - Code, Name, Preis\n  Entities/\n    ExternalDocument.cs           - Dokumentmodell mit Positionen\n\nApplication/\n  Commands/\n    ProcessLocalFileCommand.cs    - CQRS-Befehl für einzelne XML\n  Services/\n    ContractorService.cs          - Kontrahenten-Geschäftslogik\n    ItemService.cs                - Katalog-Mapping\n    DocumentProcessor.cs          - Orchestrierung des gesamten Prozesses\n  Mappers/\n    ImportMappers.cs              - ToAddContractorArgs(), NormalizeVatIsoAndDigits()\n  Options/\n    DetailContractorOptions.cs    - Einzelhandels-Kontrahenten-Konfiguration\n\nInfrastructure/\n  Persistence/\n    FirebirdDbContext.cs          - EF Core (schreibgeschützte Wörterbücher)\n    Procedures/\n      FirebirdContractorProcedures.cs - ADO.NET-Aufrufe\n      FirebirdProcedureBase.cs        - Abstraktion mit Verbindungsverwaltung\n  XmlParsing/\n    TemplateDetector.cs           - erkennt XML-Typ anhand Struktur\n    Parsers/\n      SpFvatParser.cs             - USt-Rechnungen SP-System\n      MgPkwParser.cs              - Umlagerungen MG\n      ZlPayloadBuilder.cs         - Wareneingänge ZL\n\nHost/\n  Workers/\n    MainWorker.cs                 - FileSystemWatcher + Polling\n  Program.cs                      - DI-Setup, NLog, MediatR\n```\n\n### Wichtige Muster\n\n**CQRS** - ProcessLocalFileCommand trennt Anfrage von Ausführung\n\n**Repository + Procedure Facade** - FirebirdProcedureBase erzwingt:\n```csharp\npublic abstract class FirebirdProcedureBase\n{\n    protected FbConnection CreateConnection() \n    {\n        // Unabhängige Verbindung, NICHT aus DbContext\n        // ConnectionLifeTime=60 verhindert SocketException\n        return new FbConnection(_connectionString);\n    }\n}\n```\n\n**Strategy Pattern** - verschiedene XML-Parser für verschiedene Quellen\n\n**Drei-Stufen-Dokumenttyp-Auflösung**:\n1. Matrix-Lookup (DOC_ID aus XML → Prestiž-Typ)\n2. Parser-bestimmt (Parser leitet selbst ab)\n3. Inferenz (Regex auf Dokumentnummer \"FA/2024/001\" → FA)\n\n## Firebird-Datenbank Deep Dive\n\n### Wichtige Constraints und Fallstricke\n\n**KONTRAH.NAZWASKR** - UNIQUE(BAZAKONTRAH, NAZWASKR):\n```sql\n-- Problem: \"Hans Müller\" existiert bereits als TYPKONTRAH=1 (Firma)\n-- Neuer \"Hans Müller\" als TYPKONTRAH=2 (Privatperson) → CONSTRAINT VIOLATION\n\n-- Lösung in Procedure:\nIF (TYPKONTRAH = 2) THEN\n  NAZWA = NAZWA || ' (' || NEW_NRKONTRAH || ')';\n-- Ergebnis: \"Hans Müller (10821)\"\n```\n\n**NRKONTRAH-Eindeutigkeit**:\n```sql\n-- Muss eindeutig sein in KONTRAH (PK) UND in SLOWNIK (NRKSIEGOWY)\n-- Trigger KONTRAH_BI fügt automatisch in SLOWNIK ein:\nCREATE TRIGGER KONTRAH_BI FOR KONTRAH BEFORE INSERT\nAS BEGIN\n  INSERT INTO SLOWNIK (NRKSIEGOWY, ...) \n  VALUES (NEW.NRKONTRAH, ...);\nEND\n\n-- Generierung erfordert Prüfung BEIDER Tabellen:\nWHILE EXISTS(SELECT 1 FROM KONTRAH WHERE NRKONTRAH = :candidate)\n   OR EXISTS(SELECT 1 FROM SLOWNIK WHERE NRKSIEGOWY = :candidate)\nDO\n  candidate = candidate + 1;\n```\n\n**ID_DEFDOK Magic Numbers**:\n- 5 = Standard-USt-Rechnung\n- 10 = Einzelhandelsrechnung (ohne USt-IdNr.)\n```csharp\n// Nach Erstellung des Dokuments für Privatperson ohne USt-IdNr.:\nif (parsedDoc.Contractor.Nip == null && docType.StartsWith(\"F\"))\n{\n    await _dbContext.Database.ExecuteSqlRawAsync(\n        \"UPDATE URZZEWNAGL SET ID_DEFDOK = 10 WHERE ID_URZZEWNAGL = {0}\",\n        docId\n    );\n}\n```\n\n### ARIT_AUTOSTACJA_ADD_CONTRACTOR Procedure\n\n**Signatur**:\n```sql\nCREATE PROCEDURE ARIT_AUTOSTACJA_ADD_CONTRACTOR (\n    ID_ZRODLA       INTEGER,\n    NIP             VARCHAR(25),      -- nur Ziffern, kein Länderpräfix\n    NIP_KRAJ        CHAR(2),          -- \"PL\", \"DE\", \"CZ\", ...\n    NAZWA           VARCHAR(240),\n    MIEJSCOWOSC     VARCHAR(100),\n    ULICA           VARCHAR(100),\n    NRDOMU          VARCHAR(20),\n    NRLOKALU        VARCHAR(20),\n    KODPOCZTOWY     VARCHAR(20),\n    TELEFON         VARCHAR(50),\n    EMAIL           VARCHAR(100),\n    ID_KRAJ         INTEGER,\n    REGON           VARCHAR(20),\n    KONTR_RODZAJ    VARCHAR(10),\n    KOD_FK          VARCHAR(50),\n    KOD_EWIDENCYJNY VARCHAR(50),\n    TYPKONTRAH      SMALLINT          -- 1=Firma, 2=Privatperson\n)\nRETURNS (\n    ID_KONTRAH      INTEGER,\n    ID_DANEKONTRAH  INTEGER,\n    STATUS          VARCHAR(20),      -- 'EXISTS', 'CREATED', 'FAILED'\n    ERROR_MSG       VARCHAR(500)\n)\n```\n\n**Suchlogik**:\n```sql\n-- 1. Wenn USt-IdNr. nicht leer → in DANEKONTRAH suchen\nIF (NIP IS NOT NULL AND NIP <> '') THEN\nBEGIN\n  SELECT FIRST 1 ID_KONTRAH, ID_DANEKONTRAH\n  FROM DANEKONTRAH\n  WHERE NIP = :NIP OR NIPW = :NIP_KRAJ || :NIP\n  INTO :ID_KONTRAH, :ID_DANEKONTRAH;\n  \n  IF (ID_KONTRAH IS NOT NULL) THEN\n    SUSPEND; -- existierenden zurückgeben\nEND\n\n-- 2. USt-IdNr. leer oder nicht gefunden → neu erstellen\n-- NRKONTRAH generieren:\nCANDIDATE = (SELECT MAX(NRKONTRAH) FROM KONTRAH) + 1;\nWHILE EXISTS(...) DO CANDIDATE = CANDIDATE + 1;\n\n-- Für Privatpersonen Nummer zum Namen hinzufügen:\nIF (TYPKONTRAH = 2) THEN\n  NAZWA = NAZWA || ' (' || CANDIDATE || ')';\n\nINSERT INTO KONTRAH (...) VALUES (...);\nINSERT INTO DANEKONTRAH (...) VALUES (...);\n-- Trigger KONTRAH_BI fügt automatisch in SLOWNIK ein\n```\n\n### Länder-ISO2 → ID_KRAJ-Mapping\n\n```csharp\n// ImportMappers.cs\nprivate static readonly Dictionary<string, int> CountryMapping = new()\n{\n    [\"PL\"] = 1,      [\"AT\"] = 10001, [\"BE\"] = 10002, [\"DK\"] = 10003,\n    [\"FI\"] = 10004,  [\"FR\"] = 10005, [\"EL\"] = 10006, [\"ES\"] = 10007,\n    [\"NL\"] = 10008,  [\"IE\"] = 10009, [\"LU\"] = 10010, [\"DE\"] = 10011,\n    [\"IT\"] = 10012,  [\"PT\"] = 10013, [\"SE\"] = 10014, [\"GB\"] = 10015,\n    [\"CY\"] = 10016,  [\"CZ\"] = 10017, [\"EE\"] = 10018, [\"LT\"] = 10019,\n    [\"LV\"] = 10020,  [\"MT\"] = 10021, [\"SK\"] = 10022, [\"SI\"] = 10023,\n    [\"HU\"] = 10024\n};\n\npublic static (string iso2, string digits) NormalizeVatIsoAndDigits(string nip)\n{\n    // \"DE123456789\" → (\"DE\", \"123456789\")\n    // \"PL1234567890\" → (\"PL\", \"1234567890\")\n    // \"123456\" → (\"PL\", \"123456\") // Fallback für polnische ohne Präfix\n    \n    if (string.IsNullOrWhiteSpace(nip)) return (\"PL\", string.Empty);\n    \n    var match = Regex.Match(nip, @\"^([A-Z]{2})([0-9]+)$\");\n    if (match.Success)\n        return (match.Groups[1].Value, match.Groups[2].Value);\n    \n    // Nur Ziffern → PL annehmen\n    var digitsOnly = Regex.Replace(nip, @\"[^0-9]\", \"\");\n    return (\"PL\", digitsOnly);\n}\n```\n\n## Kontrahenten-Logik - Entscheidungsbaum\n\n### Dokument HAT USt-IdNr.\n\n```csharp\n// ContractorService.EnsureContractorExistsAsync()\npublic async Task<int> EnsureContractorExistsAsync(\n    ContractorRef contractor, \n    string documentType)\n{\n    if (!string.IsNullOrWhiteSpace(contractor.Nip))\n    {\n        // 1. USt-IdNr. parsen: \"DE123\" → (\"DE\", \"123\")\n        var (iso2, digits) = NormalizeVatIsoAndDigits(contractor.Nip);\n        var idKraj = CountryIdByIso2(iso2);\n        \n        // 2. Procedure mit TYPKONTRAH=1 (Firma) aufrufen\n        var result = await _contractorProcs.AddContractorAsync(\n            new AddContractorArgs(\n                IdZrodla: _sourceId,\n                Nip: digits,\n                NipVatCountryIso2: iso2,\n                Nazwa: contractor.Name,\n                // ... Adresse ...\n                IdKraj: idKraj,\n                TypKontrah: 1  // Firma\n            )\n        );\n        \n        // 3. Procedure gibt existierenden zurück oder erstellt neuen\n        if (result.Status == \"FAILED\")\n            throw new InvalidOperationException(result.ErrorMsg);\n        \n        return result.IdKontrah;\n    }\n    // ... Logik für keine USt-IdNr. ...\n}\n```\n\n### Dokument OHNE USt-IdNr.\n\n**Kassenbons (PAR/KPAR)**:\n```csharp\nif (documentType.StartsWith(\"PAR\") || documentType == \"KPAR\")\n{\n    // Einzelhandels-Kontrahent aus Konfiguration verwenden\n    // appsettings.json: \"DetailContractor\": { \"Id\": 10818, \"Code\": \"DETAL\" }\n    return await GetDetailContractorIdAsync();\n}\n```\n\n**Einzelhandelsrechnungen (FS/FA ohne USt-IdNr.)**:\n```csharp\nif (documentType.StartsWith(\"F\")) // FA, FS, FV, FVAT\n{\n    // Privatperson erstellen (TYPKONTRAH=2)\n    var result = await _contractorProcs.AddContractorAsync(\n        new AddContractorArgs(\n            // ... vollständige Daten aus XML ...\n            TypKontrah: 2  // Privatperson\n        )\n    );\n    \n    // Procedure fügt \" (NRKONTRAH)\" automatisch zum Namen hinzu\n    // Beispiel: \"Hans Müller\" → \"Hans Müller (10821)\"\n    \n    return result.IdKontrah;\n}\n```\n\n**Andere Dokumente ohne USt-IdNr.**:\n```csharp\n// Kassen-/Lagerdokument ohne Kontrahent\nreturn 1; // \"Einmal-\" Kontrahenten-ID in Prestiž\n```\n\n**Nachbearbeitung für Einzelhandelsrechnungen**:\n```csharp\n// DocumentProcessor.ProcessAsync()\nif (contractorWasCreatedAsIndividual && docType.StartsWith(\"F\"))\n{\n    // Dokumentdefinition auf Einzelhandelsrechnung ändern\n    await _dbContext.Database.ExecuteSqlRawAsync(\n        \"UPDATE URZZEWNAGL SET ID_DEFDOK = 10 WHERE ID_URZZEWNAGL = {0}\",\n        externalDocId\n    );\n    // ID_DEFDOK=10 informiert Prestiž, dass dies Rechnung ohne USt-IdNr. ist\n}\n```\n\n## Unterstützte Dokumenttypen\n\n### Verkauf\n\n**FA/FVAT** - USt-Rechnung:\n- Mit USt-IdNr. → TYPKONTRAH=1, ID_DEFDOK=5\n- Ohne USt-IdNr. → TYPKONTRAH=2, ID_DEFDOK=10\n- Bruttopreise in XML\n\n**FS** - Verkaufsrechnung (vereinfacht):\n- Analog zu FA\n\n**PAR** - Kassenbon:\n- Immer DetailContractor (ID aus Konfiguration)\n- ID_DEFDOK=10\n- Kein Kontrahent im Header (kann in Positionen DetailContractor für andere Zwecke sein)\n\n**KPAR/KORFAS** - Kassenbon-/Rechnungskorrektur:\n- Positionsmapping nach ID_KARTOTEKA (nicht nach Positionsnummern!)\n- Prestiž ändert Reihenfolge während Realisierung:\n```csharp\n// ZlPayloadBuilder.BuildCorrectionPositions()\nforeach (var xmlLine in correctionXml.Lines)\n{\n    // XML: Position 1, 2, 3\n    // Prestiž im Basisdokument: Position 3, 1, 2 (alphabetisch sortiert)\n    \n    // Mapping nach ID_KARTOTEKA statt nach Nummer:\n    var baseDocLine = baseDocLines.FirstOrDefault(\n        l => l.IdKartoteka == xmlLine.CatalogId\n    );\n    \n    if (baseDocLine == null)\n        throw new Exception($\"Position nicht gefunden für Katalog {xmlLine.CatalogId}\");\n    \n    yield return new CorrectionPosition\n    {\n        BaseLineNumber = baseDocLine.ActualLineNumber, // aus Prestiž\n        CorrectedQty = xmlLine.Qty,\n        CorrectedPrice = xmlLine.Price\n    };\n}\n```\n\n### Lager\n\n**PZ** - Wareneingang (extern):\n- NETTO-Preise in XML (Ausnahme!)\n- Lieferant als Kontrahent\n\n**WZ** - Warenausgang (extern):\n- Empfänger als Kontrahent\n- Bruttopreise\n\n**PKW** - Umlagerung (wertmäßig):\n- Kein Kontrahent (Quelllager → Ziellager)\n- Werttransfer\n\n**PK** - Umlagerung (mengenmäßig):\n- Analog zu PKW aber nur Mengen\n\n**ZPZ/ZWPZ** - Eingangsauftrag/Rücksendung:\n- Puffer vor tatsächlichem PZ\n- Prestiž kann als PZ realisieren\n\n### Kasse\n\n**KP** - Kasseneinnahme:\n- Erfordert offenen Kassenbericht (RAPORTKBI)\n- System fügt in Puffer ein, Prestiž weist Bericht bei Realisierung zu\n- Kontrahent optional\n\n**KW** - Kassenausgabe:\n- Analog zu KP\n- Bargeldauszahlung\n\n## Connection Pooling Krise - Fallstudie\n\n### Problem\n\n```\nSystem.Net.Sockets.SocketException: \n  An existing connection was forcibly closed by the remote host\n  at FirebirdSql.Data.FbClient.GdsConnection.Receive()\n```\n\nTrat zufällig bei Batch-Verarbeitung von 10+ Dokumenten auf.\n\n### Root-Cause-Analyse\n\n**Ursprüngliche Architektur** (fehlerhaft):\n```csharp\npublic class FirebirdContractorProcedures : IContractorProcedures\n{\n    private readonly FirebirdDbContext _context;\n    \n    public async Task<AddContractorResult> AddContractorAsync(AddContractorArgs args)\n    {\n        // FEHLER: Verwendung der Verbindung aus DbContext\n        using var cmd = _context.Database.GetDbConnection().CreateCommand();\n        cmd.CommandText = \"EXECUTE PROCEDURE ARIT_AUTOSTACJA_ADD_CONTRACTOR ...\";\n        // ...\n    }\n}\n```\n\nEF Core DbContext:\n- Hält eine langlebige Verbindung\n- Connection Pooling von EF verwaltet\n- Gleichzeitige Abfragen auf derselben Verbindung → Race Conditions\n\n### Lösung\n\n**Neue Architektur**:\n```csharp\npublic abstract class FirebirdProcedureBase\n{\n    private readonly string _connectionString;\n    \n    protected FirebirdProcedureBase(IConfiguration config)\n    {\n        _connectionString = config.GetConnectionString(\"Firebird\") \n            + \";ConnectionLifeTime=60\"; // KRITISCH\n    }\n    \n    protected FbConnection CreateConnection()\n    {\n        return new FbConnection(_connectionString);\n    }\n}\n\npublic class FirebirdContractorProcedures : FirebirdProcedureBase, IContractorProcedures\n{\n    public async Task<AddContractorResult> AddContractorAsync(AddContractorArgs args)\n    {\n        // Unabhängige Verbindung für JEDEN Procedure-Aufruf\n        using var connection = CreateConnection();\n        await connection.OpenAsync();\n        \n        using var transaction = connection.BeginTransaction();\n        try\n        {\n            using var cmd = connection.CreateCommand();\n            cmd.Transaction = transaction;\n            cmd.CommandText = \"EXECUTE PROCEDURE ...\";\n            // ... Parameter ...\n            \n            using var reader = await cmd.ExecuteReaderAsync();\n            // ... Ergebnisse lesen ...\n            \n            transaction.Commit();\n            return result;\n        }\n        catch\n        {\n            transaction.Rollback();\n            throw;\n        }\n    }\n}\n```\n\n**ConnectionLifeTime=60**:\n- Firebird 3/4 hat Bug mit langlebigen Verbindungen\n- Nach 60s kehrt Verbindung zum Pool zurück und wird erneuert\n- Verhindert \"Stale Connection\" Fehler\n\n### Lessons Learned\n\n1. **KEINE Verbindungen teilen** zwischen EF Core und ADO.NET\n2. **ConnectionLifeTime** ist kritisch für Firebird\n3. **Transaktionen** immer für Procedures, die Daten ändern\n4. **using-Anweisungen** überall - Firebird toleriert keine Verbindungslecks\n\n## XML-Parsing-Architektur\n\n### Template-Erkennung\n\n```csharp\npublic class TemplateDetector\n{\n    public DocumentTemplate Detect(XDocument xml)\n    {\n        var root = xml.Root?.Name.LocalName;\n        \n        // Erkennungsstrategie nach XML-Struktur:\n        if (root == \"SalesInvoice\" && xml.Descendants(\"InvoiceNumber\").Any())\n            return DocumentTemplate.SpFvat;\n        \n        if (root == \"WarehouseMovement\" && xml.Descendants(\"MovementType\").Any())\n            return DocumentTemplate.MgPkw;\n        \n        if (xml.Descendants(\"ZamowienieHeader\").Any())\n            return DocumentTemplate.ZlOrder;\n        \n        throw new UnsupportedTemplateException($\"Unbekannte XML-Struktur: {root}\");\n    }\n}\n```\n\n### Parser-Strategie\n\n```csharp\npublic interface IXmlParser\n{\n    DocumentTemplate Template { get; }\n    IEnumerable<ParsedDocument> Parse(XDocument xml);\n}\n\npublic class SpFvatParser : IXmlParser\n{\n    public DocumentTemplate Template => DocumentTemplate.SpFvat;\n    \n    public IEnumerable<ParsedDocument> Parse(XDocument xml)\n    {\n        var invoices = xml.Descendants(\"Invoice\");\n        \n        foreach (var inv in invoices)\n        {\n            yield return new ParsedDocument\n            {\n                DocumentType = inv.Element(\"Type\")?.Value ?? \"FA\",\n                DocumentNumber = inv.Element(\"Number\")?.Value,\n                DocumentDate = ParseDate(inv.Element(\"Date\")?.Value),\n                \n                Contractor = new ContractorRef\n                {\n                    Nip = inv.Element(\"BuyerNIP\")?.Value,\n                    Name = inv.Element(\"BuyerName\")?.Value,\n                    // ... vollständige Adresse ...\n                },\n                \n                Lines = inv.Descendants(\"Line\").Select(line => new DocumentLine\n                {\n                    CatalogCode = line.Element(\"ProductCode\")?.Value,\n                    Name = line.Element(\"ProductName\")?.Value,\n                    Qty = decimal.Parse(line.Element(\"Quantity\")?.Value ?? \"0\"),\n                    PriceGross = decimal.Parse(line.Element(\"GrossPrice\")?.Value ?? \"0\"),\n                    // PZ verwendet Netto, andere Brutto:\n                    PriceNet = CalculateNetPrice(line, documentType)\n                }).ToList()\n            };\n        }\n    }\n    \n    private decimal CalculateNetPrice(XElement line, string docType)\n    {\n        if (docType == \"PZ\")\n        {\n            // Wareneingang: XML enthält Nettopreis\n            return decimal.Parse(line.Element(\"NetPrice\")?.Value ?? \"0\");\n        }\n        else\n        {\n            // Rechnungen: Netto aus Brutto berechnen\n            var gross = decimal.Parse(line.Element(\"GrossPrice\")?.Value ?? \"0\");\n            var vatRate = decimal.Parse(line.Element(\"VATRate\")?.Value ?? \"23\");\n            return gross / (1 + vatRate / 100);\n        }\n    }\n}\n```\n\n## Konfiguration und Deployment\n\n### appsettings.json\n\n```json\n{\n  \"ConnectionStrings\": {\n    \"Firebird\": \"Server=192.168.1.10;Port=3050;Database=C:\\\\Prestiz\\\\DATA\\\\PRESTIZ.FDB;User=SYSDBA;Password=masterkey;Charset=UTF8;ConnectionLifeTime=60\"\n  },\n  \n  \"Sync\": {\n    \"WatchPath\": \"\\\\\\\\file-server\\\\AutoSync\\\\IMP_FK\",\n    \"ArchivePath\": \"\\\\\\\\file-server\\\\AutoSync\\\\IMP_FK\\\\Archive\",\n    \"FailedPath\": \"\\\\\\\\file-server\\\\AutoSync\\\\IMP_FK\\\\Failed\",\n    \"PollingIntervalSeconds\": 15,\n    \"SourceId\": 1,\n    \"DefaultUserId\": \"MWD\"\n  },\n  \n  \"DetailContractor\": {\n    \"Id\": 10818,\n    \"Code\": \"DETAL\",\n    \"Name\": \"Einzelhandelskunde\"\n  },\n  \n  \"Cash\": {\n    \"DefaultCashCode\": \"1\",\n    \"DefaultCashName\": \"Hauptkasse\"\n  },\n  \n  \"ExternalDocuments\": {\n    \"DefaultUserCode\": \"MWD\",\n    \"RelatedDocCechaMapping\": {\n      \"FA\": \"CECHA2\",\n      \"PZ\": \"CECHA1\"\n    }\n  }\n}\n```\n\n### Windows-Dienst-Installation\n\n```powershell\n# Release Build\ndotnet publish -c Release -r win-x64 --self-contained true\n\n# Als Windows-Dienst installieren\nsc.exe create AutostacjaSync binPath= \"C:\\Services\\AutostacjaSync\\AutostacjaSync.Host.exe\"\nsc.exe description AutostacjaSync \"XML-Dokumentensynchronisation zu Prestiž ERP\"\nsc.exe start AutostacjaSync\n\n# Autostart beim Booten\nsc.exe config AutostacjaSync start= auto\n\n# Dienstkonto (statt LocalSystem)\nsc.exe config AutostacjaSync obj= \"DOMAIN\\\\SvcAritSync\" password= \"...\"\n```\n\n## Performance-Merkmale\n\n- **Durchsatz**: ~50 Dokumente/Minute (durchschnittliches Dokument 5-10 Positionen)\n- **Latenz**: 200-500ms von Dateierkennung bis Datenbankschreiben\n- **Speicher**: ~80MB RAM Baseline, +5MB pro gleichzeitigem Dokument\n- **Datenbanklast**: 3-5 Abfragen pro Dokument (Kontrahent, Katalog, Header, Positionen)\n- **Connection Pool**: Max 10 Verbindungen (Firebird-Limit), durchschnittlich 2-3 aktiv\n\n## Lessons Learned & Best Practices\n\n1. **Firebird-Verbindungen**: Immer unabhängige Verbindungen für Procedures, ConnectionLifeTime=60\n2. **USt-IdNr.-Behandlung**: Immer zu (ISO2, Ziffern) parsen, ID_KRAJ vor FK-Insert validieren\n3. **Unique Constraints**: Für TYPKONTRAH=2 immer Nummer zum Namen hinzufügen\n4. **Dokumentenkorrekturen**: Nach ID_KARTOTEKA mappen, niemals nach Positionsnummern\n5. **Transaction Scope**: Jede Procedure in separater Transaktion, Rollback bei Exception\n6. **Logging**: Debug-Level in DEV, Info in PROD, Error immer mit vollem Stack Trace\n7. **File Watching**: FileSystemWatcher + Polling-Backup (Netzwerkfreigaben können Events verlieren)\n8. **Fehlerbehandlung**: Fehlgeschlagene Dateien in separates Verzeichnis mit Zeitstempel, nie löschen\n9. **Umgebungsparität**: DEV-DB muss vollständige Wörterbücher haben (KRAJ, DEFDOK, etc.)\n10. **Kassendokumente**: RAPORTKBI nicht in Synchronisation validieren, Prestiž macht das\n\n## Tech-Stack - Vollständige Liste\n\n**Backend**:\n- .NET 8 (C# 12)\n- Worker Service (BackgroundService)\n- MediatR 12.x (CQRS)\n- LinqToDB 5.x (für Firebird-spezifische Abfragen)\n- EF Core 8.x (nur schreibgeschützte Wörterbücher)\n- NLog 5.x\n\n**Datenbank**:\n- Firebird 3.0 / 4.0\n- FirebirdSql.Data.FirebirdClient 10.x\n- ADO.NET für Stored Procedures\n\n**Testing** (geplant):\n- xUnit\n- Moq\n- Testcontainers.Firebird\n\n**Infrastruktur**:\n- Windows Server 2019+\n- Netzwerkfreigabe (SMB) für überwachtes Verzeichnis\n- Windows-Dienst-Hosting\n\n## Potenzielle Verbesserungen\n\n- [ ] Retry-Policy für transiente Firebird-Fehler (Polly)\n- [ ] Batch-Verarbeitung für große Importe (>100 Dokumente)\n- [ ] Health-Check-HTTP-Endpunkt\n- [ ] Metriken (Prometheus-Exporter)\n- [ ] Dokumentvorschau vor Import (optionale Validierung)\n- [ ] Web-UI zum Durchsuchen der Synchronisationshistorie\n- [ ] Unterstützung für andere ERPs (SAP, Comarch XL) über Adapter-Pattern\n- [ ] E2E-Tests mit Testcontainers + Beispiel-XMLs"
}