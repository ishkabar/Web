{
  "title": "AutostacjaSync - Document Synchronization with Prestiž ERP",
  "summary": "Critical integration layer for automotive businesses: .NET 8 Worker Service synchronizing XML documents from workshop systems to Prestiž ERP via Firebird stored procedures.",
  "content": "## Overview\n\nAutostacjaSync is a production Windows service providing automatic synchronization of business documents between external systems (car service stations, automotive wholesalers) and Prestiž ERP. The system processes dozens of XML document types, manages contractors across 25+ EU countries, handles document corrections, and ensures data consistency through advanced Firebird stored procedures.\n\nKey role: eliminating manual invoice transcription, automating warehouse receipts, synchronizing contractor data from external sources while maintaining referential integrity and uniqueness in the accounting system.\n\n## Business Context\n\n### Problem\n\nAutomotive companies use dedicated workshop systems (external XML APIs) that generate sales documents, but the main accounting and warehouse management is in Prestiž ERP (Firebird). Manual transcription:\n- Generates errors in VAT IDs, prices, quantities\n- Delays document realization by hours\n- Requires duplicate contractor data entry\n- Doesn't handle corrections automatically\n\n### Solution\n\nAutomated pipeline:\n1. External systems export XML to network directory\n2. AutostacjaSync detects, parses, validates\n3. Intelligent contractor mapping (search by VAT ID, create new with EU VAT handling)\n4. Import to URZZEWNAGL/URZZEWNPOZ buffer in Prestiž\n5. Prestiž user realizes imported document with one click\n\n### Value\n\n- **Zero manual work** for standard documents\n- **Error elimination** in VAT IDs, prices, names\n- **International compliance** - automatic EU VAT mapping (25 countries)\n- **Correction handling** - intelligent line mapping despite ERP reordering\n- **Audit trail** - complete history for every document in NLog logs\n\n## Technical Architecture\n\n### Clean Architecture + DDD Lite\n\n```\nDomain/\n  Abstractions/\n    IContractorProcedures.cs      - ARIT_AUTOSTACJA_ADD_CONTRACTOR contract\n    IItemProcedures.cs            - ARIT_AUTOSTACJA_ADD_ITEM\n    IExternalDocProcedures.cs     - URZZEWNAGL_ADD_10, URZZEWNPOZ_ADD_10\n  ValueObjects/\n    ContractorRef.cs              - VAT ID, name, address (immutable)\n    ItemRef.cs                    - code, name, price\n  Entities/\n    ExternalDocument.cs           - document model with lines\n\nApplication/\n  Commands/\n    ProcessLocalFileCommand.cs    - CQRS command for single XML\n  Services/\n    ContractorService.cs          - contractor business logic\n    ItemService.cs                - catalog mapping\n    DocumentProcessor.cs          - entire process orchestration\n  Mappers/\n    ImportMappers.cs              - ToAddContractorArgs(), NormalizeVatIsoAndDigits()\n  Options/\n    DetailContractorOptions.cs    - retail contractor configuration\n\nInfrastructure/\n  Persistence/\n    FirebirdDbContext.cs          - EF Core (read-only dictionaries)\n    Procedures/\n      FirebirdContractorProcedures.cs - ADO.NET calls\n      FirebirdProcedureBase.cs        - abstraction with connection management\n  XmlParsing/\n    TemplateDetector.cs           - detects XML type by structure\n    Parsers/\n      SpFvatParser.cs             - VAT invoices SP system\n      MgPkwParser.cs              - inter-warehouse transfers MG\n      ZlPayloadBuilder.cs         - warehouse receipts ZL\n\nHost/\n  Workers/\n    MainWorker.cs                 - FileSystemWatcher + polling\n  Program.cs                      - DI setup, NLog, MediatR\n```\n\n### Key Patterns\n\n**CQRS** - ProcessLocalFileCommand separates request from execution\n\n**Repository + Procedure Facade** - FirebirdProcedureBase enforces:\n```csharp\npublic abstract class FirebirdProcedureBase\n{\n    protected FbConnection CreateConnection() \n    {\n        // Independent connection, NOT from DbContext\n        // ConnectionLifeTime=60 prevents SocketException\n        return new FbConnection(_connectionString);\n    }\n}\n```\n\n**Strategy Pattern** - different XML parsers for different sources\n\n**Three-Tier Document Type Resolution**:\n1. Matrix lookup (DOC_ID from XML → Prestiž type)\n2. Parser-determined (parser deduces itself)\n3. Inference (regex on document number \"FA/2024/001\" → FA)\n\n## Firebird Database Deep Dive\n\n### Key Constraints and Pitfalls\n\n**KONTRAH.NAZWASKR** - UNIQUE(BAZAKONTRAH, NAZWASKR):\n```sql\n-- Problem: \"John Smith\" already exists as TYPKONTRAH=1 (company)\n-- New \"John Smith\" as TYPKONTRAH=2 (individual) → CONSTRAINT VIOLATION\n\n-- Solution in procedure:\nIF (TYPKONTRAH = 2) THEN\n  NAZWA = NAZWA || ' (' || NEW_NRKONTRAH || ')';\n-- Result: \"John Smith (10821)\"\n```\n\n**NRKONTRAH Uniqueness**:\n```sql\n-- Must be unique in KONTRAH (PK) AND in SLOWNIK (NRKSIEGOWY)\n-- Trigger KONTRAH_BI automatically inserts to SLOWNIK:\nCREATE TRIGGER KONTRAH_BI FOR KONTRAH BEFORE INSERT\nAS BEGIN\n  INSERT INTO SLOWNIK (NRKSIEGOWY, ...) \n  VALUES (NEW.NRKONTRAH, ...);\nEND\n\n-- Generation requires checking BOTH tables:\nWHILE EXISTS(SELECT 1 FROM KONTRAH WHERE NRKONTRAH = :candidate)\n   OR EXISTS(SELECT 1 FROM SLOWNIK WHERE NRKSIEGOWY = :candidate)\nDO\n  candidate = candidate + 1;\n```\n\n**ID_DEFDOK Magic Numbers**:\n- 5 = Standard VAT invoice\n- 10 = Retail invoice (no VAT ID)\n```csharp\n// After creating document for individual without VAT ID:\nif (parsedDoc.Contractor.Nip == null && docType.StartsWith(\"F\"))\n{\n    await _dbContext.Database.ExecuteSqlRawAsync(\n        \"UPDATE URZZEWNAGL SET ID_DEFDOK = 10 WHERE ID_URZZEWNAGL = {0}\",\n        docId\n    );\n}\n```\n\n### ARIT_AUTOSTACJA_ADD_CONTRACTOR Procedure\n\n**Signature**:\n```sql\nCREATE PROCEDURE ARIT_AUTOSTACJA_ADD_CONTRACTOR (\n    ID_ZRODLA       INTEGER,\n    NIP             VARCHAR(25),      -- digits only, no country prefix\n    NIP_KRAJ        CHAR(2),          -- \"PL\", \"DE\", \"CZ\", ...\n    NAZWA           VARCHAR(240),\n    MIEJSCOWOSC     VARCHAR(100),\n    ULICA           VARCHAR(100),\n    NRDOMU          VARCHAR(20),\n    NRLOKALU        VARCHAR(20),\n    KODPOCZTOWY     VARCHAR(20),\n    TELEFON         VARCHAR(50),\n    EMAIL           VARCHAR(100),\n    ID_KRAJ         INTEGER,\n    REGON           VARCHAR(20),\n    KONTR_RODZAJ    VARCHAR(10),\n    KOD_FK          VARCHAR(50),\n    KOD_EWIDENCYJNY VARCHAR(50),\n    TYPKONTRAH      SMALLINT          -- 1=company, 2=individual\n)\nRETURNS (\n    ID_KONTRAH      INTEGER,\n    ID_DANEKONTRAH  INTEGER,\n    STATUS          VARCHAR(20),      -- 'EXISTS', 'CREATED', 'FAILED'\n    ERROR_MSG       VARCHAR(500)\n)\n```\n\n**Search Logic**:\n```sql\n-- 1. If VAT ID not empty → search in DANEKONTRAH\nIF (NIP IS NOT NULL AND NIP <> '') THEN\nBEGIN\n  SELECT FIRST 1 ID_KONTRAH, ID_DANEKONTRAH\n  FROM DANEKONTRAH\n  WHERE NIP = :NIP OR NIPW = :NIP_KRAJ || :NIP\n  INTO :ID_KONTRAH, :ID_DANEKONTRAH;\n  \n  IF (ID_KONTRAH IS NOT NULL) THEN\n    SUSPEND; -- return existing\nEND\n\n-- 2. VAT ID empty or not found → create new\n-- Generate NRKONTRAH:\nCANDIDATE = (SELECT MAX(NRKONTRAH) FROM KONTRAH) + 1;\nWHILE EXISTS(...) DO CANDIDATE = CANDIDATE + 1;\n\n-- For individuals add number to name:\nIF (TYPKONTRAH = 2) THEN\n  NAZWA = NAZWA || ' (' || CANDIDATE || ')';\n\nINSERT INTO KONTRAH (...) VALUES (...);\nINSERT INTO DANEKONTRAH (...) VALUES (...);\n-- Trigger KONTRAH_BI automatically inserts to SLOWNIK\n```\n\n### Country ISO2 → ID_KRAJ Mapping\n\n```csharp\n// ImportMappers.cs\nprivate static readonly Dictionary<string, int> CountryMapping = new()\n{\n    [\"PL\"] = 1,      [\"AT\"] = 10001, [\"BE\"] = 10002, [\"DK\"] = 10003,\n    [\"FI\"] = 10004,  [\"FR\"] = 10005, [\"EL\"] = 10006, [\"ES\"] = 10007,\n    [\"NL\"] = 10008,  [\"IE\"] = 10009, [\"LU\"] = 10010, [\"DE\"] = 10011,\n    [\"IT\"] = 10012,  [\"PT\"] = 10013, [\"SE\"] = 10014, [\"GB\"] = 10015,\n    [\"CY\"] = 10016,  [\"CZ\"] = 10017, [\"EE\"] = 10018, [\"LT\"] = 10019,\n    [\"LV\"] = 10020,  [\"MT\"] = 10021, [\"SK\"] = 10022, [\"SI\"] = 10023,\n    [\"HU\"] = 10024\n};\n\npublic static (string iso2, string digits) NormalizeVatIsoAndDigits(string nip)\n{\n    // \"DE123456789\" → (\"DE\", \"123456789\")\n    // \"PL1234567890\" → (\"PL\", \"1234567890\")\n    // \"123456\" → (\"PL\", \"123456\") // fallback for Polish without prefix\n    \n    if (string.IsNullOrWhiteSpace(nip)) return (\"PL\", string.Empty);\n    \n    var match = Regex.Match(nip, @\"^([A-Z]{2})([0-9]+)$\");\n    if (match.Success)\n        return (match.Groups[1].Value, match.Groups[2].Value);\n    \n    // Digits only → assume PL\n    var digitsOnly = Regex.Replace(nip, @\"[^0-9]\", \"\");\n    return (\"PL\", digitsOnly);\n}\n```\n\n## Contractor Logic - Decision Tree\n\n### Document HAS VAT ID\n\n```csharp\n// ContractorService.EnsureContractorExistsAsync()\npublic async Task<int> EnsureContractorExistsAsync(\n    ContractorRef contractor, \n    string documentType)\n{\n    if (!string.IsNullOrWhiteSpace(contractor.Nip))\n    {\n        // 1. Parse VAT ID: \"DE123\" → (\"DE\", \"123\")\n        var (iso2, digits) = NormalizeVatIsoAndDigits(contractor.Nip);\n        var idKraj = CountryIdByIso2(iso2);\n        \n        // 2. Call procedure with TYPKONTRAH=1 (company)\n        var result = await _contractorProcs.AddContractorAsync(\n            new AddContractorArgs(\n                IdZrodla: _sourceId,\n                Nip: digits,\n                NipVatCountryIso2: iso2,\n                Nazwa: contractor.Name,\n                // ... address ...\n                IdKraj: idKraj,\n                TypKontrah: 1  // company\n            )\n        );\n        \n        // 3. Procedure returns existing or creates new\n        if (result.Status == \"FAILED\")\n            throw new InvalidOperationException(result.ErrorMsg);\n        \n        return result.IdKontrah;\n    }\n    // ... logic for no VAT ID ...\n}\n```\n\n### Document WITHOUT VAT ID\n\n**Receipts (PAR/KPAR)**:\n```csharp\nif (documentType.StartsWith(\"PAR\") || documentType == \"KPAR\")\n{\n    // Use retail contractor from configuration\n    // appsettings.json: \"DetailContractor\": { \"Id\": 10818, \"Code\": \"DETAL\" }\n    return await GetDetailContractorIdAsync();\n}\n```\n\n**Retail invoices (FS/FA without VAT ID)**:\n```csharp\nif (documentType.StartsWith(\"F\")) // FA, FS, FV, FVAT\n{\n    // Create individual (TYPKONTRAH=2)\n    var result = await _contractorProcs.AddContractorAsync(\n        new AddContractorArgs(\n            // ... full data from XML ...\n            TypKontrah: 2  // individual\n        )\n    );\n    \n    // Procedure adds \" (NRKONTRAH)\" to name automatically\n    // Example: \"John Smith\" → \"John Smith (10821)\"\n    \n    return result.IdKontrah;\n}\n```\n\n**Other documents without VAT ID**:\n```csharp\n// Cash/warehouse document without contractor\nreturn 1; // \"one-time\" contractor ID in Prestiž\n```\n\n**Post-processing for retail invoices**:\n```csharp\n// DocumentProcessor.ProcessAsync()\nif (contractorWasCreatedAsIndividual && docType.StartsWith(\"F\"))\n{\n    // Change document definition to retail invoice\n    await _dbContext.Database.ExecuteSqlRawAsync(\n        \"UPDATE URZZEWNAGL SET ID_DEFDOK = 10 WHERE ID_URZZEWNAGL = {0}\",\n        externalDocId\n    );\n    // ID_DEFDOK=10 informs Prestiž this is invoice without VAT ID\n}\n```\n\n## Supported Document Types\n\n### Sales\n\n**FA/FVAT** - VAT Invoice:\n- With VAT ID → TYPKONTRAH=1, ID_DEFDOK=5\n- Without VAT ID → TYPKONTRAH=2, ID_DEFDOK=10\n- Gross prices in XML\n\n**FS** - Sales Invoice (simplified):\n- Analogous to FA\n\n**PAR** - Fiscal Receipt:\n- Always DetailContractor (ID from configuration)\n- ID_DEFDOK=10\n- No contractor in header (may be DetailContractor in lines for other purposes)\n\n**KPAR/KORFAS** - Receipt/invoice correction:\n- Line mapping by ID_KARTOTEKA (not by line numbers!)\n- Prestiž changes order during realization:\n```csharp\n// ZlPayloadBuilder.BuildCorrectionPositions()\nforeach (var xmlLine in correctionXml.Lines)\n{\n    // XML: position 1, 2, 3\n    // Prestiž in base document: position 3, 1, 2 (sorted alphabetically)\n    \n    // Map by ID_KARTOTEKA instead of number:\n    var baseDocLine = baseDocLines.FirstOrDefault(\n        l => l.IdKartoteka == xmlLine.CatalogId\n    );\n    \n    if (baseDocLine == null)\n        throw new Exception($\"Line not found for catalog {xmlLine.CatalogId}\");\n    \n    yield return new CorrectionPosition\n    {\n        BaseLineNumber = baseDocLine.ActualLineNumber, // from Prestiž\n        CorrectedQty = xmlLine.Qty,\n        CorrectedPrice = xmlLine.Price\n    };\n}\n```\n\n### Warehouse\n\n**PZ** - External Receipt:\n- NET prices in XML (exception!)\n- Supplier as contractor\n\n**WZ** - External Issue:\n- Recipient as contractor\n- Gross prices\n\n**PKW** - Inter-warehouse Transfer (value):\n- No contractor (source warehouse → destination)\n- Value transfer\n\n**PK** - Inter-warehouse Transfer (quantity):\n- Analogous to PKW but quantity only\n\n**ZPZ/ZWPZ** - Receipt order/return:\n- Buffer before actual PZ\n- Prestiž can realize as PZ\n\n### Cash\n\n**KP** - Cash Receipt:\n- Requires open cash report (RAPORTKBI)\n- System inserts to buffer, Prestiž assigns report during realization\n- Contractor optional\n\n**KW** - Cash Disbursement:\n- Analogous to KP\n- Cash withdrawal\n\n## Connection Pooling Crisis - Case Study\n\n### Problem\n\n```\nSystem.Net.Sockets.SocketException: \n  An existing connection was forcibly closed by the remote host\n  at FirebirdSql.Data.FbClient.GdsConnection.Receive()\n```\n\nOccurred randomly during batch processing of 10+ documents.\n\n### Root Cause Analysis\n\n**Original architecture** (incorrect):\n```csharp\npublic class FirebirdContractorProcedures : IContractorProcedures\n{\n    private readonly FirebirdDbContext _context;\n    \n    public async Task<AddContractorResult> AddContractorAsync(AddContractorArgs args)\n    {\n        // ERROR: using connection from DbContext\n        using var cmd = _context.Database.GetDbConnection().CreateCommand();\n        cmd.CommandText = \"EXECUTE PROCEDURE ARIT_AUTOSTACJA_ADD_CONTRACTOR ...\";\n        // ...\n    }\n}\n```\n\nEF Core DbContext:\n- Holds one long-lived connection\n- Connection pooling managed by EF\n- Concurrent queries on same connection → race conditions\n\n### Solution\n\n**New architecture**:\n```csharp\npublic abstract class FirebirdProcedureBase\n{\n    private readonly string _connectionString;\n    \n    protected FirebirdProcedureBase(IConfiguration config)\n    {\n        _connectionString = config.GetConnectionString(\"Firebird\") \n            + \";ConnectionLifeTime=60\"; // CRITICAL\n    }\n    \n    protected FbConnection CreateConnection()\n    {\n        return new FbConnection(_connectionString);\n    }\n}\n\npublic class FirebirdContractorProcedures : FirebirdProcedureBase, IContractorProcedures\n{\n    public async Task<AddContractorResult> AddContractorAsync(AddContractorArgs args)\n    {\n        // Independent connection for EVERY procedure call\n        using var connection = CreateConnection();\n        await connection.OpenAsync();\n        \n        using var transaction = connection.BeginTransaction();\n        try\n        {\n            using var cmd = connection.CreateCommand();\n            cmd.Transaction = transaction;\n            cmd.CommandText = \"EXECUTE PROCEDURE ...\";\n            // ... parameters ...\n            \n            using var reader = await cmd.ExecuteReaderAsync();\n            // ... read results ...\n            \n            transaction.Commit();\n            return result;\n        }\n        catch\n        {\n            transaction.Rollback();\n            throw;\n        }\n    }\n}\n```\n\n**ConnectionLifeTime=60**:\n- Firebird 3/4 has bug with long-lived connections\n- After 60s connection returns to pool and is renewed\n- Prevents \"stale connection\" errors\n\n### Lessons Learned\n\n1. **DON'T share connections** between EF Core and ADO.NET\n2. **ConnectionLifeTime** is critical for Firebird\n3. **Transactions** always for procedures modifying data\n4. **using statements** everywhere - Firebird doesn't tolerate leaked connections\n\n## XML Parsing Architecture\n\n### Template Detection\n\n```csharp\npublic class TemplateDetector\n{\n    public DocumentTemplate Detect(XDocument xml)\n    {\n        var root = xml.Root?.Name.LocalName;\n        \n        // Detection strategy by XML structure:\n        if (root == \"SalesInvoice\" && xml.Descendants(\"InvoiceNumber\").Any())\n            return DocumentTemplate.SpFvat;\n        \n        if (root == \"WarehouseMovement\" && xml.Descendants(\"MovementType\").Any())\n            return DocumentTemplate.MgPkw;\n        \n        if (xml.Descendants(\"ZamowienieHeader\").Any())\n            return DocumentTemplate.ZlOrder;\n        \n        throw new UnsupportedTemplateException($\"Unknown XML structure: {root}\");\n    }\n}\n```\n\n### Parser Strategy\n\n```csharp\npublic interface IXmlParser\n{\n    DocumentTemplate Template { get; }\n    IEnumerable<ParsedDocument> Parse(XDocument xml);\n}\n\npublic class SpFvatParser : IXmlParser\n{\n    public DocumentTemplate Template => DocumentTemplate.SpFvat;\n    \n    public IEnumerable<ParsedDocument> Parse(XDocument xml)\n    {\n        var invoices = xml.Descendants(\"Invoice\");\n        \n        foreach (var inv in invoices)\n        {\n            yield return new ParsedDocument\n            {\n                DocumentType = inv.Element(\"Type\")?.Value ?? \"FA\",\n                DocumentNumber = inv.Element(\"Number\")?.Value,\n                DocumentDate = ParseDate(inv.Element(\"Date\")?.Value),\n                \n                Contractor = new ContractorRef\n                {\n                    Nip = inv.Element(\"BuyerNIP\")?.Value,\n                    Name = inv.Element(\"BuyerName\")?.Value,\n                    // ... full address ...\n                },\n                \n                Lines = inv.Descendants(\"Line\").Select(line => new DocumentLine\n                {\n                    CatalogCode = line.Element(\"ProductCode\")?.Value,\n                    Name = line.Element(\"ProductName\")?.Value,\n                    Qty = decimal.Parse(line.Element(\"Quantity\")?.Value ?? \"0\"),\n                    PriceGross = decimal.Parse(line.Element(\"GrossPrice\")?.Value ?? \"0\"),\n                    // PZ uses net, others gross:\n                    PriceNet = CalculateNetPrice(line, documentType)\n                }).ToList()\n            };\n        }\n    }\n    \n    private decimal CalculateNetPrice(XElement line, string docType)\n    {\n        if (docType == \"PZ\")\n        {\n            // Warehouse receipt: XML contains net price\n            return decimal.Parse(line.Element(\"NetPrice\")?.Value ?? \"0\");\n        }\n        else\n        {\n            // Invoices: calculate net from gross\n            var gross = decimal.Parse(line.Element(\"GrossPrice\")?.Value ?? \"0\");\n            var vatRate = decimal.Parse(line.Element(\"VATRate\")?.Value ?? \"23\");\n            return gross / (1 + vatRate / 100);\n        }\n    }\n}\n```\n\n### Document Type Resolution - Three Tiers\n\n```csharp\npublic class DocumentTypeResolver\n{\n    private readonly IDocumentMatrixRepository _matrix;\n    \n    public string Resolve(ParsedDocument doc, XDocument originalXml)\n    {\n        // Tier 1: Matrix lookup (DOC_ID from XML → type in Prestiž)\n        var docId = originalXml.Root?.Attribute(\"DOC_ID\")?.Value;\n        if (!string.IsNullOrEmpty(docId))\n        {\n            var mapped = _matrix.GetTypeByDocId(docId);\n            if (mapped != null)\n            {\n                _logger.Debug($\"Matrix mapped DOC_ID={docId} → {mapped}\");\n                return mapped;\n            }\n        }\n        \n        // Tier 2: Parser-determined (parser knows type from XML context)\n        if (!string.IsNullOrEmpty(doc.DocumentType))\n        {\n            _logger.Debug($\"Parser determined type: {doc.DocumentType}\");\n            return doc.DocumentType;\n        }\n        \n        // Tier 3: Inference from document number\n        var inferred = InferFromNumber(doc.DocumentNumber);\n        _logger.Debug($\"Inferred from number '{doc.DocumentNumber}': {inferred}\");\n        return inferred;\n    }\n    \n    private string InferFromNumber(string number)\n    {\n        // \"FA/2024/001\" → \"FA\"\n        // \"PZ/MAG1/123\" → \"PZ\"\n        // \"2024/12/PAR/001\" → \"PAR\"\n        \n        var match = Regex.Match(number, @\"\\b(FA|FS|FVAT|PZ|WZ|PAR|KP|KW|PKW|PK)\\b\");\n        return match.Success ? match.Value : \"FA\"; // fallback\n    }\n}\n```\n\n## Document Processing Pipeline\n\n```csharp\npublic class DocumentProcessor\n{\n    private readonly IContractorService _contractorSvc;\n    private readonly IItemService _itemSvc;\n    private readonly IExternalDocProcedures _docProcs;\n    private readonly FirebirdDbContext _context;\n    \n    public async Task<ProcessResult> ProcessAsync(\n        ParsedDocument doc, \n        string sourceFile)\n    {\n        _logger.Info($\"Processing document {doc.DocumentNumber} from {sourceFile}\");\n        \n        try\n        {\n            // 1. Ensure contractor exists\n            var contractorId = await _contractorSvc.EnsureContractorExistsAsync(\n                doc.Contractor, \n                doc.DocumentType\n            );\n            _logger.Debug($\"Contractor ID: {contractorId}\");\n            \n            // 2. Map catalog (all lines)\n            var catalogMapping = new Dictionary<string, int>();\n            foreach (var line in doc.Lines)\n            {\n                if (!catalogMapping.ContainsKey(line.CatalogCode))\n                {\n                    var itemId = await _itemSvc.EnsureItemExistsAsync(\n                        line.CatalogCode,\n                        line.Name,\n                        line.IsService\n                    );\n                    catalogMapping[line.CatalogCode] = itemId;\n                }\n            }\n            _logger.Debug($\"Mapped {catalogMapping.Count} catalog items\");\n            \n            // 3. Create document header\n            var docId = await _docProcs.CreateHeaderAsync(new CreateHeaderArgs\n            {\n                DocumentType = doc.DocumentType,\n                DocumentNumber = doc.DocumentNumber,\n                DocumentDate = doc.DocumentDate,\n                ContractorId = contractorId,\n                TotalGross = doc.Lines.Sum(l => l.Qty * l.PriceGross),\n                TotalNet = doc.Lines.Sum(l => l.Qty * l.PriceNet),\n                SourceId = _sourceId,\n                UserId = _defaultUserId\n            });\n            _logger.Info($\"Created document header ID={docId}\");\n            \n            // 4. Add lines\n            int lineNumber = 0;\n            foreach (var line in doc.Lines)\n            {\n                lineNumber++;\n                await _docProcs.AddLineAsync(new AddLineArgs\n                {\n                    HeaderId = docId,\n                    LineNumber = lineNumber,\n                    ItemId = catalogMapping[line.CatalogCode],\n                    Qty = line.Qty,\n                    PriceNet = line.PriceNet,\n                    PriceGross = line.PriceGross,\n                    VatRate = line.VatRate\n                });\n            }\n            _logger.Debug($\"Added {lineNumber} lines\");\n            \n            // 5. Post-processing for retail invoices\n            if (contractorId != 1 && \n                string.IsNullOrEmpty(doc.Contractor.Nip) && \n                doc.DocumentType.StartsWith(\"F\"))\n            {\n                await _context.Database.ExecuteSqlRawAsync(\n                    \"UPDATE URZZEWNAGL SET ID_DEFDOK = 10 WHERE ID_URZZEWNAGL = {0}\",\n                    docId\n                );\n                _logger.Info($\"Updated to retail invoice (ID_DEFDOK=10)\");\n            }\n            \n            return ProcessResult.Success(docId);\n        }\n        catch (Exception ex)\n        {\n            _logger.Error(ex, $\"Failed to process document {doc.DocumentNumber}\");\n            return ProcessResult.Failure(ex.Message);\n        }\n    }\n}\n```\n\n## Worker Service Architecture\n\n```csharp\npublic class MainWorker : BackgroundService\n{\n    private readonly IMediator _mediator;\n    private readonly SyncOptions _options;\n    private FileSystemWatcher? _watcher;\n    \n    protected override async Task ExecuteAsync(CancellationToken ct)\n    {\n        _logger.Info($\"Starting AutostacjaSync v{Assembly.GetExecutingAssembly().GetName().Version}\");\n        _logger.Info($\"Watch path: {_options.WatchPath}\");\n        \n        // FileSystemWatcher for immediate detection\n        _watcher = new FileSystemWatcher(_options.WatchPath, \"*.xml\")\n        {\n            NotifyFilter = NotifyFilters.FileName | NotifyFilters.LastWrite,\n            EnableRaisingEvents = true\n        };\n        _watcher.Created += OnFileCreated;\n        \n        // Backup polling every N seconds (if watcher fails)\n        while (!ct.IsCancellationRequested)\n        {\n            await ScanDirectoryAsync();\n            await Task.Delay(\n                TimeSpan.FromSeconds(_options.PollingIntervalSeconds), \n                ct\n            );\n        }\n    }\n    \n    private void OnFileCreated(object sender, FileSystemEventArgs e)\n    {\n        _logger.Debug($\"FileSystemWatcher detected: {e.Name}\");\n        _ = ProcessFileAsync(e.FullPath); // fire and forget\n    }\n    \n    private async Task ScanDirectoryAsync()\n    {\n        var files = Directory.GetFiles(_options.WatchPath, \"*.xml\");\n        _logger.Debug($\"Polling scan found {files.Length} XML files\");\n        \n        foreach (var file in files)\n        {\n            await ProcessFileAsync(file);\n        }\n    }\n    \n    private async Task ProcessFileAsync(string filePath)\n    {\n        try\n        {\n            // Wait for file to be fully written (antivirus, network delays)\n            await WaitForFileReady(filePath);\n            \n            var command = new ProcessLocalFileCommand(filePath);\n            var result = await _mediator.Send(command);\n            \n            if (result.Success)\n            {\n                var archivePath = Path.Combine(\n                    _options.ArchivePath,\n                    $\"{Path.GetFileNameWithoutExtension(filePath)}_\" +\n                    $\"{DateTime.Now:yyyyMMdd_HHmmss}{Path.GetExtension(filePath)}\"\n                );\n                File.Move(filePath, archivePath);\n                _logger.Info($\"Archived: {archivePath}\");\n            }\n            else\n            {\n                var failedPath = Path.Combine(\n                    _options.FailedPath,\n                    Path.GetFileName(filePath)\n                );\n                File.Move(filePath, failedPath);\n                _logger.Error($\"Failed, moved to: {failedPath}. Error: {result.ErrorMessage}\");\n            }\n        }\n        catch (Exception ex)\n        {\n            _logger.Error(ex, $\"Error processing file {filePath}\");\n        }\n    }\n    \n    private async Task WaitForFileReady(string filePath, int maxWaitMs = 5000)\n    {\n        var waited = 0;\n        while (waited < maxWaitMs)\n        {\n            try\n            {\n                using var stream = File.Open(filePath, FileMode.Open, FileAccess.Read, FileShare.None);\n                return; // File ready\n            }\n            catch (IOException)\n            {\n                await Task.Delay(100);\n                waited += 100;\n            }\n        }\n        throw new TimeoutException($\"File {filePath} not ready after {maxWaitMs}ms\");\n    }\n}\n```\n\n## Production Challenges\n\n### Environment-Specific Data Inconsistencies\n\nIdentical code, different behavior DEV vs PROD:\n\n**Problem**: ARIT_AUTOSTACJA_ADD_CONTRACTOR procedure works in PROD, fails in DEV\n\n**Root cause**:\n```sql\n-- DEV: KRAJ table has gaps in ID_KRAJ\nSELECT ID_KRAJ, KODKRAJU_VAT_UE FROM KRAJ ORDER BY ID_KRAJ;\n-- 1 (PL), 10001 (AT), missing 10011 (DE) ← MISSING!\n\n-- PROD: Complete table\n-- 1 (PL), 10001 (AT), 10011 (DE), ...\n\n-- C# code:\nvar idKraj = CountryIdByIso2(\"DE\"); // 10011\n// DEV: FK constraint violation, ID=10011 missing in KRAJ\n// PROD: OK\n```\n\n**Solution**: Check before calling procedure\n```csharp\nvar idKraj = CountryIdByIso2(iso2);\nif (idKraj != 1) // not PL\n{\n    var exists = await _context.Kraj\n        .AnyAsync(k => k.IdKraj == idKraj);\n    if (!exists)\n    {\n        _logger.Warning($\"Country {iso2} (ID={idKraj}) missing in DEV, fallback to PL\");\n        idKraj = 1;\n    }\n}\n```\n\n### Cash Document Validation\n\nKP/KW documents require open cash report:\n\n```csharp\n// Problem: How to find open report for document date?\n// RAPORTKBI.ZAMKNIETY = 0 AND DATAOD <= DocDate <= DATADO\n\n// Solution: DON'T validate in synchronization\n// Prestiž will assign report during document realization\n// If no open report → user gets error in Prestiž\n\npublic async Task<int> CreateCashDocumentAsync(CreateCashDocArgs args)\n{\n    // Insert to buffer WITHOUT checking RAPORTKBI\n    await _docProcs.CreateHeaderAsync(new CreateHeaderArgs\n    {\n        DocumentType = args.Type, // KP or KW\n        // ... other fields ...\n        // No ID_RAPORTKBI - Prestiž will fill\n    });\n    \n    _logger.Info($\"Cash document queued, Prestiž will assign report on realization\");\n}\n```\n\n### Correction Document Mapping Hell\n\n**Problem**: Correction XML has lines 1,2,3. Prestiž in base document has 3,1,2.\n\n**Why?**: Prestiž sorts lines alphabetically by product name during realization.\n\n**Solution**: Map by ID_KARTOTEKA\n```csharp\npublic async Task<List<CorrectionLineMapping>> MapCorrectionLines(\n    int baseDocId, \n    List<ParsedDocumentLine> xmlLines)\n{\n    // 1. Get actual lines from realized document\n    var baseLines = await _context.URZZEWNPOZ\n        .Where(p => p.ID_URZZEWNAGL == baseDocId)\n        .OrderBy(p => p.LP) // LP = line position in Prestiž\n        .Select(p => new { p.LP, p.ID_KARTOTEKA, p.ILOSC, p.CENA })\n        .ToListAsync();\n    \n    // 2. Map XML by ID_KARTOTEKA (not by LP!)\n    var mappings = new List<CorrectionLineMapping>();\n    foreach (var xmlLine in xmlLines)\n    {\n        var baseLine = baseLines.FirstOrDefault(\n            bl => bl.ID_KARTOTEKA == xmlLine.CatalogId\n        );\n        \n        if (baseLine == null)\n            throw new InvalidOperationException(\n                $\"Product {xmlLine.CatalogCode} not found in base document {baseDocId}\"\n            );\n        \n        mappings.Add(new CorrectionLineMapping\n        {\n            BaseLineNumber = baseLine.LP,      // Position in Prestiž\n            XmlLineNumber = xmlLine.LineNumber, // Position in XML\n            CatalogId = xmlLine.CatalogId,\n            \n            BaseQty = baseLine.ILOSC,\n            BasePrice = baseLine.CENA,\n            \n            CorrectedQty = xmlLine.Qty,\n            CorrectedPrice = xmlLine.Price,\n            \n            QtyDelta = xmlLine.Qty - baseLine.ILOSC,\n            PriceDelta = xmlLine.Price - baseLine.CENA\n        });\n    }\n    \n    return mappings;\n}\n```\n\n## Configuration and Deployment\n\n### appsettings.json\n\n```json\n{\n  \"ConnectionStrings\": {\n    \"Firebird\": \"Server=192.168.1.10;Port=3050;Database=C:\\\\Prestiz\\\\DATA\\\\PRESTIZ.FDB;User=SYSDBA;Password=masterkey;Charset=UTF8;ConnectionLifeTime=60\"\n  },\n  \n  \"Sync\": {\n    \"WatchPath\": \"\\\\\\\\file-server\\\\AutoSync\\\\IMP_FK\",\n    \"ArchivePath\": \"\\\\\\\\file-server\\\\AutoSync\\\\IMP_FK\\\\Archive\",\n    \"FailedPath\": \"\\\\\\\\file-server\\\\AutoSync\\\\IMP_FK\\\\Failed\",\n    \"PollingIntervalSeconds\": 15,\n    \"SourceId\": 1,\n    \"DefaultUserId\": \"MWD\"\n  },\n  \n  \"DetailContractor\": {\n    \"Id\": 10818,\n    \"Code\": \"DETAL\",\n    \"Name\": \"Retail Customer\"\n  },\n  \n  \"Cash\": {\n    \"DefaultCashCode\": \"1\",\n    \"DefaultCashName\": \"Main Cash\"\n  },\n  \n  \"ExternalDocuments\": {\n    \"DefaultUserCode\": \"MWD\",\n    \"RelatedDocCechaMapping\": {\n      \"FA\": \"CECHA2\",\n      \"PZ\": \"CECHA1\"\n    }\n  },\n  \n  \"NLog\": {\n    \"targets\": {\n      \"file\": {\n        \"type\": \"File\",\n        \"fileName\": \"${basedir}/logs/sync-${shortdate}.log\",\n        \"archiveEvery\": \"Day\",\n        \"archiveNumbering\": \"Date\",\n        \"maxArchiveFiles\": 30\n      }\n    },\n    \"rules\": [\n      {\n        \"logger\": \"*\",\n        \"minLevel\": \"Debug\",\n        \"writeTo\": \"file\"\n      }\n    ]\n  }\n}\n```\n\n### Windows Service Installation\n\n```powershell\n# Build Release\ndotnet publish -c Release -r win-x64 --self-contained true\n\n# Install as Windows Service\nsc.exe create AutostacjaSync binPath= \"C:\\Services\\AutostacjaSync\\AutostacjaSync.Host.exe\"\nsc.exe description AutostacjaSync \"XML document synchronization to Prestiž ERP\"\nsc.exe start AutostacjaSync\n\n# Auto-start on boot\nsc.exe config AutostacjaSync start= auto\n\n# Service account (instead of LocalSystem)\nsc.exe config AutostacjaSync obj= \"DOMAIN\\\\SvcAritSync\" password= \"...\"\n```\n\n### Monitoring\n\n```csharp\n// HealthCheck endpoint (optional)\npublic class SyncHealthCheck : IHealthCheck\n{\n    private readonly FirebirdDbContext _context;\n    \n    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context)\n    {\n        try\n        {\n            // Test DB connectivity\n            await _context.Database.ExecuteSqlRawAsync(\"SELECT 1 FROM RDB$DATABASE\");\n            \n            // Test filesystem access\n            var testFile = Path.Combine(_options.WatchPath, \".health\");\n            File.WriteAllText(testFile, DateTime.Now.ToString());\n            File.Delete(testFile);\n            \n            return HealthCheckResult.Healthy(\"All systems operational\");\n        }\n        catch (Exception ex)\n        {\n            return HealthCheckResult.Unhealthy(\"System failure\", ex);\n        }\n    }\n}\n```\n\n## Performance Characteristics\n\n- **Throughput**: ~50 documents/minute (average document 5-10 lines)\n- **Latency**: 200-500ms from file detection to database write\n- **Memory**: ~80MB RAM baseline, +5MB per concurrent document\n- **Database load**: 3-5 queries per document (contractor, catalog, header, lines)\n- **Connection pool**: Max 10 connections (Firebird limit), average 2-3 active\n\n## Lessons Learned & Best Practices\n\n1. **Firebird Connections**: Always independent connections for procedures, ConnectionLifeTime=60\n2. **VAT ID Handling**: Always parse to (ISO2, digits), validate ID_KRAJ before FK insert\n3. **Unique Constraints**: For TYPKONTRAH=2 always add number to name\n4. **Document Corrections**: Map by ID_KARTOTEKA, never by line numbers\n5. **Transaction Scope**: Each procedure in separate transaction, rollback on exception\n6. **Logging**: Debug level in DEV, Info in PROD, Error always with full stack trace\n7. **File Watching**: FileSystemWatcher + polling backup (network shares may lose events)\n8. **Error Handling**: Failed files to separate directory with timestamp, never delete\n9. **Environment Parity**: DEV DB must have complete dictionaries (KRAJ, DEFDOK, etc.)\n10. **Cash Documents**: Don't validate RAPORTKBI in synchronization, Prestiž will do it\n\n## Tech Stack - Complete List\n\n**Backend**:\n- .NET 8 (C# 12)\n- Worker Service (BackgroundService)\n- MediatR 12.x (CQRS)\n- LinqToDB 5.x (for Firebird-specific queries)\n- EF Core 8.x (read-only dictionaries only)\n- NLog 5.x\n\n**Database**:\n- Firebird 3.0 / 4.0\n- FirebirdSql.Data.FirebirdClient 10.x\n- ADO.NET for stored procedures\n\n**Testing** (planned):\n- xUnit\n- Moq\n- Testcontainers.Firebird\n\n**Infrastructure**:\n- Windows Server 2019+\n- Network share (SMB) for watched directory\n- Windows Service hosting\n\n## Potential Improvements\n\n- [ ] Retry policy for transient Firebird errors (Polly)\n- [ ] Batch processing for large imports (>100 documents)\n- [ ] Health check HTTP endpoint\n- [ ] Metrics (Prometheus exporter)\n- [ ] Document preview before import (optional validation)\n- [ ] Web UI for browsing synchronization history\n- [ ] Support for other ERPs (SAP, Comarch XL) via adapter pattern\n- [ ] E2E tests with Testcontainers + sample XMLs"
}