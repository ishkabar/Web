#!/usr/bin/env node
/**
 * Generate i18n locales from folder names:
 *   src/messages/<locale>/<locale>.json
 * Produces: src/i18n/locales.generated.ts
 */
import fs from 'fs';
import path from 'path';

const ROOT = process.cwd();
const MSG_DIR = path.join(ROOT, 'src', 'messages');
const OUT_DIR = path.join(ROOT, 'src', 'i18n');
const OUT_FILE = path.join(OUT_DIR, 'locales.generated.ts');

type Meta = { label?: string; flag?: string; default?: boolean };
type LocaleEntry = { code: string; meta: Meta };

const PRIORITY: string[] = ['pl', 'en', 'de','da','fr','cz','it','nl','no','fi','sv','ja','es'];
const ENABLED: string[] = ['pl', 'en', 'de','da','fr','cz','it','nl','no','fi','sv','ja','es'];

function safeReadJson(p: string): any | null {
    try {
        if (!fs.existsSync(p)) return null;
        const raw = fs.readFileSync(p, 'utf-8');
        return JSON.parse(raw);
    } catch {
        return null;
    }
}

function main() {
    if (!fs.existsSync(MSG_DIR)) {
        console.error(`[i18n] Not found: ${MSG_DIR}`);
        process.exit(1);
    }

    const dirs = fs.readdirSync(MSG_DIR, { withFileTypes: true })
        .filter(d => d.isDirectory())
        .map(d => d.name);

    if (dirs.length === 0) {
        console.error('[i18n] No locale directories found under src/messages');
        process.exit(1);
    }

    const entries: LocaleEntry[] = [];
    for (const code of dirs) {
        const jsonPath = path.join(MSG_DIR, code, `${code}.json`);
        const raw = safeReadJson(jsonPath);
        const meta: Meta = (raw?.meta ?? {}) as Meta;
        if (!raw) {
            console.warn(`[i18n] Warning: missing ${path.relative(ROOT, jsonPath)}; using defaults for "${code}"`);
        }
        entries.push({ code, meta });
    }

    const present = new Set(entries.map(e => e.code));
    const explicitDefaults = entries.filter(e => e.meta?.default);
    let defaultLocale: string | undefined = explicitDefaults[0]?.code;
    if (!defaultLocale) {
        defaultLocale = PRIORITY.find(p => present.has(p)) ?? undefined;
    }

    const head = PRIORITY.filter(p => present.has(p));
    const tail = entries
        .map(e => e.code)
        .filter(c => !head.includes(c))
        .sort((a, b) => a.localeCompare(b));
    const locales = [...head, ...tail];
    const enabledLocales = ENABLED.filter(p => present.has(p));

    if (!defaultLocale) defaultLocale = locales[0];

    const metaMap: Record<string, { label: string; flag: string }> = {};
    for (const e of entries) {
        metaMap[e.code] = {
            label: e.meta.label ?? e.code,
            flag:  e.meta.flag  ?? e.code
        };
    }

    if (!fs.existsSync(OUT_DIR)) fs.mkdirSync(OUT_DIR, { recursive: true });

    const content =
        `/* AUTO-GENERATED by scripts/gen-locales.ts â€“ DO NOT EDIT */
export const locales = ${JSON.stringify(locales)} as const;
export type Locale = typeof locales[number];
export const defaultLocale: Locale = ${JSON.stringify(defaultLocale)} as Locale;

export const enabledLocales = ${JSON.stringify(enabledLocales)} as const;
export type EnabledLocale = typeof enabledLocales[number];


export const localeMeta: Record<Locale, {label: string; flag: string}> = ${JSON.stringify(metaMap, null, 2)} as any;

export function isLocale(x: string): x is Locale {
  return (locales as readonly string[]).includes(x);
}
`;
    fs.writeFileSync(OUT_FILE, content, 'utf-8');
    console.info(`[i18n] Generated: ${path.relative(ROOT, OUT_FILE)} (${locales.length} locales, default=${defaultLocale})`);

}

main();
